#define private public
#define protected public
#include "python_util.h"
// This file has been generated by Py++.

#include "boost/python.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "boost/python/suite/indexing/map_indexing_suite.hpp"

#include "common_util.h"

#include "log_util.h"

#include "Segmentor.h"
const int gezi::SegHandle::SEG_BUFF_SIZE;
const int gezi::NerHandle::MAX_TERM_COUNT;

namespace bp = boost::python;

struct NerHandle_wrapper : gezi::NerHandle, bp::wrapper< gezi::NerHandle > {

NerHandle_wrapper(gezi::NerHandle const & arg )
: gezi::NerHandle( arg )
, bp::wrapper< gezi::NerHandle >(){
// copy constructor

}

NerHandle_wrapper( )
: gezi::NerHandle( )
, bp::wrapper< gezi::NerHandle >(){
// null constructor

}

static ::ner_out_t * get_pout(gezi::NerHandle const & inst ){
return inst.pout;
}

static void set_pout( gezi::NerHandle & inst, ::ner_out_t * new_value ){
inst.pout = new_value;
}

};

struct SegHandle_wrapper : gezi::SegHandle, bp::wrapper< gezi::SegHandle > {

SegHandle_wrapper(gezi::SegHandle const & arg )
: gezi::SegHandle( arg )
, bp::wrapper< gezi::SegHandle >(){
// copy constructor

}

SegHandle_wrapper(int bufsize=gezi::SegHandle::SEG_BUFF_SIZE )
: gezi::SegHandle( bufsize )
, bp::wrapper< gezi::SegHandle >(){
// constructor

}

static ::scw_out_t * get_pout(gezi::SegHandle const & inst ){
return inst.pout;
}

static void set_pout( gezi::SegHandle & inst, ::scw_out_t * new_value ){
inst.pout = new_value;
}

static ::token_t * get_tokens(gezi::SegHandle const & inst ){
return inst.tokens;
}

static void set_tokens( gezi::SegHandle & inst, ::token_t * new_value ){
inst.tokens = new_value;
}

};

BOOST_PYTHON_MODULE(libsegment){
DEF_VEC(ivec);
DEF_VEC(dvec);
DEF_VEC(uvec);
DEF_VEC(svec);
DEF_VEC(ulvec);
DEF_MAP(id_map);
DEF_MAP(sd_map);
DEF_MAP(si_map);
DEF_MAP(ss_map);
DEF_PAIR(ii_pair);
DEF_PAIR(si_pair);
DEF_PAIR(wsi_pair);
DEF_VEC(si_pair_vec);
DEF_VEC(wsi_pair_vec);
DEF_SET(sset);
DEF_SET(iset);
DEF_SET(lset);
DEF_SET(ulset);

{ //::std::vector< token_t >
typedef bp::class_< std::vector< token_t > > vector_less__token_t__greater__exposer_t;
vector_less__token_t__greater__exposer_t vector_less__token_t__greater__exposer = vector_less__token_t__greater__exposer_t( "vector_less__token_t__greater_" );
bp::scope vector_less__token_t__greater__scope( vector_less__token_t__greater__exposer );
//WARNING: the next line of code will not compile, because "::token_t" does not have operator== !
//         vector_less__token_t__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< token_t > >() );
}

{ //::std::vector< std::string >
typedef bp::class_< std::vector< std::string > > vector_less__std_scope_string__greater__exposer_t;
vector_less__std_scope_string__greater__exposer_t vector_less__std_scope_string__greater__exposer = vector_less__std_scope_string__greater__exposer_t( "vector_less__std_scope_string__greater_" );
bp::scope vector_less__std_scope_string__greater__scope( vector_less__std_scope_string__greater__exposer );
vector_less__std_scope_string__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< std::string >, true >() )
VEC_METHOD(::std::vector< std::string >);
}

bp::class_< std::vector< gezi::SegNode > >("vector_less__gezi_scope_SegNode__greater_")
.def( bp::vector_indexing_suite< ::std::vector< gezi::SegNode > >() )
VEC_METHOD(::std::vector< gezi::SegNode >);

bp::class_< std::vector< gezi::NerNode > >("vector_less__gezi_scope_NerNode__greater_")
.def( bp::vector_indexing_suite< ::std::vector< gezi::NerNode > >() )
VEC_METHOD(::std::vector< gezi::NerNode >);

bp::class_< std::vector< float > >("vector_less__float__greater_")
.def( bp::vector_indexing_suite< ::std::vector< float >, true >() )
VEC_METHOD(::std::vector< float >);

bp::class_< std::map< std::string, float > >("map_less__std_scope_string_comma__float__greater_")
.def( bp::map_indexing_suite< ::std::map< std::string, float >, true >() )
MAP_METHOD(::std::map< std::string COMMA  float >);

bp::class_< NerHandle_wrapper, boost::noncopyable >( "NerHandle", bp::no_init )
.def( bp::init< >() )
.def(
"clear"
, (void ( ::gezi::NerHandle::* )(  ))( &::gezi::NerHandle::clear ) )
.def(
"size"
, (::size_t ( ::gezi::NerHandle::* )(  ))( &::gezi::NerHandle::size ) )
.def(
"subtag_size"
, (::size_t ( ::gezi::NerHandle::* )(  ))( &::gezi::NerHandle::subtag_size ) )
.def_readonly( "MAX_TERM_COUNT", &gezi::NerHandle::MAX_TERM_COUNT )
.def_readwrite( "nresult", &gezi::NerHandle::nresult )
.add_property( "pout"
, bp::make_function( (::ner_out_t * (*)( ::gezi::NerHandle const & ))(&NerHandle_wrapper::get_pout), bp::return_internal_reference< >() )
, bp::make_function( (void (*)( ::gezi::NerHandle &,::ner_out_t * ))(&NerHandle_wrapper::set_pout), bp::with_custodian_and_ward_postcall< 1, 2 >() ) )
.def_readwrite( "seg_type", &gezi::NerHandle::seg_type );

bp::class_< gezi::NerNode >( "NerNode", bp::init< >() )
.def( bp::init< std::string, int, bp::optional< std::string > >(( bp::arg("word_"), bp::arg("type_"), bp::arg("name_")="" )) )
.def( bp::self == bp::self )
.def_readwrite( "name", &gezi::NerNode::name )
.def_readwrite( "type", &gezi::NerNode::type )
.def_readwrite( "word", &gezi::NerNode::word );

{ //::gezi::SegHandle
typedef bp::class_< SegHandle_wrapper, boost::noncopyable > SegHandle_exposer_t;
SegHandle_exposer_t SegHandle_exposer = SegHandle_exposer_t( "SegHandle", bp::init< bp::optional< int > >(( bp::arg("bufsize")=(int)(gezi::SegHandle::SEG_BUFF_SIZE) )) );
bp::scope SegHandle_scope( SegHandle_exposer );
bp::implicitly_convertible< int, gezi::SegHandle >();
{ //::gezi::SegHandle::clear

typedef void ( ::gezi::SegHandle::*clear_function_type)(  ) ;

SegHandle_exposer.def(
"clear"
, clear_function_type( &::gezi::SegHandle::clear ) );

}
{ //::gezi::SegHandle::gen_offsets

typedef void ( ::gezi::SegHandle::*gen_offsets_function_type)(  ) ;

SegHandle_exposer.def(
"gen_offsets"
, gen_offsets_function_type( &::gezi::SegHandle::gen_offsets ) );

}
{ //::gezi::SegHandle::init

typedef void ( ::gezi::SegHandle::*init_function_type)( int ) ;

SegHandle_exposer.def(
"init"
, init_function_type( &::gezi::SegHandle::init )
, ( bp::arg("buf_size_")=(int)(gezi::SegHandle::SEG_BUFF_SIZE) ) );

}
{ //::gezi::SegHandle::len

typedef ::size_t ( ::gezi::SegHandle::*len_function_type)( int ) const;

SegHandle_exposer.def(
"len"
, len_function_type( &::gezi::SegHandle::len )
, ( bp::arg("i") ) );

}
{ //::gezi::SegHandle::offset

typedef ::size_t ( ::gezi::SegHandle::*offset_function_type)( int ) const;

SegHandle_exposer.def(
"offset"
, offset_function_type( &::gezi::SegHandle::offset )
, ( bp::arg("i") ) );

}
{ //::gezi::SegHandle::size

typedef ::size_t ( ::gezi::SegHandle::*size_function_type)(  ) const;

SegHandle_exposer.def(
"size"
, size_function_type( &::gezi::SegHandle::size ) );

}
{ //::gezi::SegHandle::type

typedef ::size_t ( ::gezi::SegHandle::*type_function_type)( int ) const;

SegHandle_exposer.def(
"type"
, type_function_type( &::gezi::SegHandle::type )
, ( bp::arg("i") ) );

}
{ //::gezi::SegHandle::weight

typedef ::size_t ( ::gezi::SegHandle::*weight_function_type)( int ) const;

SegHandle_exposer.def(
"weight"
, weight_function_type( &::gezi::SegHandle::weight )
, ( bp::arg("i") ) );

}
{ //::gezi::SegHandle::word

typedef ::std::string ( ::gezi::SegHandle::*word_function_type)( int ) const;

SegHandle_exposer.def(
"word"
, word_function_type( &::gezi::SegHandle::word )
, ( bp::arg("i") ) );

}
SegHandle_exposer.def_readonly( "SEG_BUFF_SIZE", &gezi::SegHandle::SEG_BUFF_SIZE );
SegHandle_exposer.def_readwrite( "buf_size", &gezi::SegHandle::buf_size );
SegHandle_exposer.def_readwrite( "nresult", &gezi::SegHandle::nresult );
SegHandle_exposer.add_property( "pout"
, bp::make_function( (::scw_out_t * (*)( ::gezi::SegHandle const & ))(&SegHandle_wrapper::get_pout), bp::return_internal_reference< >() )
, bp::make_function( (void (*)( ::gezi::SegHandle &,::scw_out_t * ))(&SegHandle_wrapper::set_pout), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
SegHandle_exposer.def_readwrite( "seg_type", &gezi::SegHandle::seg_type );
SegHandle_exposer.def_readwrite( "token_vec", &gezi::SegHandle::token_vec );
SegHandle_exposer.add_property( "tokens"
, bp::make_function( (::token_t * (*)( ::gezi::SegHandle const & ))(&SegHandle_wrapper::get_tokens), bp::return_internal_reference< >() )
, bp::make_function( (void (*)( ::gezi::SegHandle &,::token_t * ))(&SegHandle_wrapper::set_tokens), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
}

bp::class_< gezi::SegNode >( "SegNode", bp::init< >() )
.def( bp::init< std::string, int, int, int, int >(( bp::arg("word_"), bp::arg("length_"), bp::arg("offset_"), bp::arg("type_"), bp::arg("weight_") )) )
.def( bp::self == bp::self )
.def_readwrite( "offset", &gezi::SegNode::offset )
.def_readwrite( "length", &gezi::SegNode::length )
.def_readwrite( "type", &gezi::SegNode::type )
.def_readwrite( "weight", &gezi::SegNode::weight )
.def_readwrite( "word", &gezi::SegNode::word );

{ //::gezi::Segmentor
typedef bp::class_< gezi::Segmentor > Segmentor_exposer_t;
Segmentor_exposer_t Segmentor_exposer = Segmentor_exposer_t( "Segmentor", bp::init< bp::optional< int > >(( bp::arg("seg_buff_size")=(int)(gezi::SegHandle::SEG_BUFF_SIZE) )) );
bp::scope Segmentor_scope( Segmentor_exposer );
bp::implicitly_convertible< int, gezi::Segmentor >();
{ //::gezi::Segmentor::AddStrategy

typedef void ( *AddStrategy_function_type )( int );

Segmentor_exposer.def(
"AddStrategy"
, AddStrategy_function_type( &::gezi::Segmentor::AddStrategy )
, ( bp::arg("strategy_") ) );

}
{ //::gezi::Segmentor::Cut

typedef ::std::vector< gezi::SegNode > ( *Cut_function_type )( ::std::string,int );

Segmentor_exposer.def(
"Cut"
, Cut_function_type( &::gezi::Segmentor::Cut )
, ( bp::arg("input"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::GetNerNodes

typedef ::std::vector< gezi::NerNode > ( *GetNerNodes_function_type )( ::std::string,bool );

Segmentor_exposer.def(
"GetNerNodes"
, GetNerNodes_function_type( &::gezi::Segmentor::GetNerNodes )
, ( bp::arg("text"), bp::arg("filter")=(bool)(false) ) );

}
{ //::gezi::Segmentor::GetNerNodes

typedef ::std::vector< gezi::NerNode > ( *GetNerNodes_function_type )( bool );

Segmentor_exposer.def(
"GetNerNodes"
, GetNerNodes_function_type( &::gezi::Segmentor::GetNerNodes )
, ( bp::arg("filter")=(bool)(false) ) );

}
{ //::gezi::Segmentor::GetSegNodes

typedef ::std::vector< gezi::SegNode > ( *GetSegNodes_function_type )(  );

Segmentor_exposer.def(
"GetSegNodes"
, GetSegNodes_function_type( &::gezi::Segmentor::GetSegNodes ) );

}
{ //::gezi::Segmentor::GetSubNerNodes

typedef ::std::vector< gezi::NerNode > ( *GetSubNerNodes_function_type )( ::std::string,bool );

Segmentor_exposer.def(
"GetSubNerNodes"
, GetSubNerNodes_function_type( &::gezi::Segmentor::GetSubNerNodes )
, ( bp::arg("text"), bp::arg("filter")=(bool)(false) ) );

}
{ //::gezi::Segmentor::GetSubNerNodes

typedef ::std::vector< gezi::NerNode > ( *GetSubNerNodes_function_type )( bool );

Segmentor_exposer.def(
"GetSubNerNodes"
, GetSubNerNodes_function_type( &::gezi::Segmentor::GetSubNerNodes )
, ( bp::arg("filter")=(bool)(false) ) );

}
{ //::gezi::Segmentor::GetTokens

typedef int ( *GetTokens_function_type )( int );

Segmentor_exposer.def(
"GetTokens"
, GetTokens_function_type( &::gezi::Segmentor::GetTokens )
, ( bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::GetWordRank

typedef float ( *GetWordRank_function_type )( int,int,::std::vector< float > const & );

Segmentor_exposer.def(
"GetWordRank"
, GetWordRank_function_type( &::gezi::Segmentor::GetWordRank )
, ( bp::arg("offset"), bp::arg("length"), bp::arg("values") ) );

}
{ //::gezi::Segmentor::Init

typedef bool ( *Init_function_type )( int,::std::string,int,::std::string,bool,int );

Segmentor_exposer.def(
"Init"
, Init_function_type( &::gezi::Segmentor::Init )
, ( bp::arg("seg_buff_size")=(int)(gezi::SegHandle::SEG_BUFF_SIZE), bp::arg("data_dir")="./data/wordseg", bp::arg("type")=(int)(gezi::SEG_USE_DEFAULT), bp::arg("conf_path")="./conf/scw.conf", bp::arg("need_split_dict")=(bool)(false), bp::arg("ner_maxterm_count")=(int)(gezi::NerHandle::MAX_TERM_COUNT) ) );

}
{ //::gezi::Segmentor::InitThread

typedef void ( *InitThread_function_type )( int,int );

Segmentor_exposer.def(
"InitThread"
, InitThread_function_type( &::gezi::Segmentor::InitThread )
, ( bp::arg("seg_buff_size")=(int)(gezi::SegHandle::SEG_BUFF_SIZE), bp::arg("ner_maxterm_count")=(int)(gezi::NerHandle::MAX_TERM_COUNT) ) );

}
{ //::gezi::Segmentor::MergeNewword

typedef void ( *MergeNewword_function_type )(  );

Segmentor_exposer.def(
"MergeNewword"
, MergeNewword_function_type( &::gezi::Segmentor::MergeNewword ) );

}
{ //::gezi::Segmentor::NerTag

typedef bool ( *NerTag_function_type )(  );

Segmentor_exposer.def(
"NerTag"
, NerTag_function_type( &::gezi::Segmentor::NerTag ) );

}
{ //::gezi::Segmentor::NerTag

typedef bool ( *NerTag_function_type )( ::gezi::SegHandle & );

Segmentor_exposer.def(
"NerTag"
, NerTag_function_type( &::gezi::Segmentor::NerTag )
, ( bp::arg("handle") ) );

}
{ //::gezi::Segmentor::NerWordRank

typedef ::std::vector< float > ( *NerWordRank_function_type )( ::std::vector< float > const & );

Segmentor_exposer.def(
"NerWordRank"
, NerWordRank_function_type( &::gezi::Segmentor::NerWordRank )
, ( bp::arg("values") ) );

}
{ //::gezi::Segmentor::NerWordRank

typedef ::std::vector< float > ( *NerWordRank_function_type )(  );

Segmentor_exposer.def(
"NerWordRank"
, NerWordRank_function_type( &::gezi::Segmentor::NerWordRank ) );

}
{ //::gezi::Segmentor::NerWordRankMap

typedef ::std::map< std::string, float > ( *NerWordRankMap_function_type )( ::std::vector< float > const & );

Segmentor_exposer.def(
"NerWordRankMap"
, NerWordRankMap_function_type( &::gezi::Segmentor::NerWordRankMap )
, ( bp::arg("ner_values") ) );

}
{ //::gezi::Segmentor::NerWordRankMap

typedef ::std::map< std::string, float > ( *NerWordRankMap_function_type )( ::std::string,::std::vector< float > const & );

Segmentor_exposer.def(
"NerWordRankMap"
, NerWordRankMap_function_type( &::gezi::Segmentor::NerWordRankMap )
, ( bp::arg("text"), bp::arg("ner_values") ) );

}
{ //::gezi::Segmentor::NerWordRankMap

typedef ::std::map< std::string, float > ( *NerWordRankMap_function_type )(  );

Segmentor_exposer.def(
"NerWordRankMap"
, NerWordRankMap_function_type( &::gezi::Segmentor::NerWordRankMap ) );

}
{ //::gezi::Segmentor::NerWordRankMap

typedef ::std::map< std::string, float > ( *NerWordRankMap_function_type )( ::std::string );

Segmentor_exposer.def(
"NerWordRankMap"
, NerWordRankMap_function_type( &::gezi::Segmentor::NerWordRankMap )
, ( bp::arg("text") ) );

}
{ //::gezi::Segmentor::Seg

typedef bool ( *Seg_function_type )( ::std::string,int );

Segmentor_exposer.def(
"Seg"
, Seg_function_type( &::gezi::Segmentor::Seg )
, ( bp::arg("input"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::SegWords

typedef bool ( *SegWords_function_type )( ::std::string );

Segmentor_exposer.def(
"SegWords"
, SegWords_function_type( &::gezi::Segmentor::SegWords )
, ( bp::arg("input") ) );

}
{ //::gezi::Segmentor::Segment

typedef ::std::vector< std::string > ( *Segment_function_type )( ::std::string,int );

Segmentor_exposer.def(
"Segment"
, Segment_function_type( &::gezi::Segmentor::Segment )
, ( bp::arg("input"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::Segment

typedef bool ( *Segment_function_type )( ::std::string,::std::vector< std::string > &,int );

Segmentor_exposer.def(
"Segment"
, Segment_function_type( &::gezi::Segmentor::Segment )
, ( bp::arg("input"), bp::arg("result"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::Segment

typedef ::std::string ( *Segment_function_type )( ::std::string,::std::string,int );

Segmentor_exposer.def(
"Segment"
, Segment_function_type( &::gezi::Segmentor::Segment )
, ( bp::arg("input"), bp::arg("sep"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::Segment

typedef bool ( *Segment_function_type )( ::std::string,::std::vector< gezi::SegNode > &,int );

Segmentor_exposer.def(
"Segment"
, Segment_function_type( &::gezi::Segmentor::Segment )
, ( bp::arg("input"), bp::arg("result"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::Segment_

typedef bool ( *Segment__function_type )( ::std::string,int );

Segmentor_exposer.def(
"Segment_"
, Segment__function_type( &::gezi::Segmentor::Segment_ )
, ( bp::arg("input"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::SetFlag

typedef void ( *SetFlag_function_type )( int );

Segmentor_exposer.def(
"SetFlag"
, SetFlag_function_type( &::gezi::Segmentor::SetFlag )
, ( bp::arg("flag_") ) );

}
{ //::gezi::Segmentor::SetStrategy

typedef void ( *SetStrategy_function_type )( int );

Segmentor_exposer.def(
"SetStrategy"
, SetStrategy_function_type( &::gezi::Segmentor::SetStrategy )
, ( bp::arg("strategy_") ) );

}
{ //::gezi::Segmentor::TagPostag

typedef bool ( *TagPostag_function_type )(  );

Segmentor_exposer.def(
"TagPostag"
, TagPostag_function_type( &::gezi::Segmentor::TagPostag ) );

}
{ //::gezi::Segmentor::Uninit

typedef void ( *Uninit_function_type )(  );

Segmentor_exposer.def(
"Uninit"
, Uninit_function_type( &::gezi::Segmentor::Uninit ) );

}
{ //::gezi::Segmentor::UseWordNer

typedef bool ( *UseWordNer_function_type )(  );

Segmentor_exposer.def(
"UseWordNer"
, UseWordNer_function_type( &::gezi::Segmentor::UseWordNer ) );

}
{ //::gezi::Segmentor::UseWordRank

typedef bool ( *UseWordRank_function_type )(  );

Segmentor_exposer.def(
"UseWordRank"
, UseWordRank_function_type( &::gezi::Segmentor::UseWordRank ) );

}
{ //::gezi::Segmentor::WordRank

typedef ::std::vector< float > ( *WordRank_function_type )(  );

Segmentor_exposer.def(
"WordRank"
, WordRank_function_type( &::gezi::Segmentor::WordRank ) );

}
{ //::gezi::Segmentor::WordRankMap

typedef ::std::map< std::string, float > ( *WordRankMap_function_type )( ::std::vector< float > const & );

Segmentor_exposer.def(
"WordRankMap"
, WordRankMap_function_type( &::gezi::Segmentor::WordRankMap )
, ( bp::arg("values") ) );

}
{ //::gezi::Segmentor::WordRankMap

typedef ::std::map< std::string, float > ( *WordRankMap_function_type )(  );

Segmentor_exposer.def(
"WordRankMap"
, WordRankMap_function_type( &::gezi::Segmentor::WordRankMap ) );

}
{ //::gezi::Segmentor::add_strategy

typedef void ( *add_strategy_function_type )( int );

Segmentor_exposer.def(
"add_strategy"
, add_strategy_function_type( &::gezi::Segmentor::add_strategy )
, ( bp::arg("strategy_") ) );

}
{ //::gezi::Segmentor::cut

typedef ::std::vector< gezi::SegNode > ( ::gezi::Segmentor::*cut_function_type)( ::std::string,int ) ;

Segmentor_exposer.def(
"cut"
, cut_function_type( &::gezi::Segmentor::cut )
, ( bp::arg("input"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::get_handle

typedef ::gezi::SegHandle & ( ::gezi::Segmentor::*get_handle_function_type)(  ) ;

Segmentor_exposer.def(
"get_handle"
, get_handle_function_type( &::gezi::Segmentor::get_handle )
, bp::return_internal_reference<>());

}
{ //::gezi::Segmentor::get_nernodes

typedef ::std::vector< gezi::NerNode > ( *get_nernodes_function_type )( ::std::string,::gezi::SegHandle const &,::gezi::NerHandle const &,bool );

Segmentor_exposer.def(
"get_nernodes"
, get_nernodes_function_type( &::gezi::Segmentor::get_nernodes )
, ( bp::arg("text"), bp::arg("handle"), bp::arg("ner_handle"), bp::arg("filter")=(bool)(false) ) );

}
{ //::gezi::Segmentor::get_nernodes

typedef ::std::vector< gezi::NerNode > ( *get_nernodes_function_type )( ::gezi::SegHandle const &,::gezi::NerHandle const &,bool );

Segmentor_exposer.def(
"get_nernodes"
, get_nernodes_function_type( &::gezi::Segmentor::get_nernodes )
, ( bp::arg("handle"), bp::arg("ner_handle"), bp::arg("filter")=(bool)(false) ) );

}
{ //::gezi::Segmentor::get_segnodes

typedef ::std::vector< gezi::SegNode > ( *get_segnodes_function_type )( ::gezi::SegHandle const & );

Segmentor_exposer.def(
"get_segnodes"
, get_segnodes_function_type( &::gezi::Segmentor::get_segnodes )
, ( bp::arg("handle") ) );

}
{ //::gezi::Segmentor::get_segnodes

typedef ::std::vector< gezi::SegNode > ( ::gezi::Segmentor::*get_segnodes_function_type)(  ) ;

Segmentor_exposer.def(
"get_segnodes"
, get_segnodes_function_type( &::gezi::Segmentor::get_segnodes ) );

}
{ //::gezi::Segmentor::get_sub_nernodes

typedef ::std::vector< gezi::NerNode > ( *get_sub_nernodes_function_type )( ::std::string,::gezi::SegHandle const &,::gezi::NerHandle const &,bool );

Segmentor_exposer.def(
"get_sub_nernodes"
, get_sub_nernodes_function_type( &::gezi::Segmentor::get_sub_nernodes )
, ( bp::arg("text"), bp::arg("handle"), bp::arg("ner_handle"), bp::arg("filter")=(bool)(false) ) );

}
{ //::gezi::Segmentor::get_sub_nernodes

typedef ::std::vector< gezi::NerNode > ( *get_sub_nernodes_function_type )( ::gezi::SegHandle const &,::gezi::NerHandle const &,bool );

Segmentor_exposer.def(
"get_sub_nernodes"
, get_sub_nernodes_function_type( &::gezi::Segmentor::get_sub_nernodes )
, ( bp::arg("handle"), bp::arg("ner_handle"), bp::arg("filter")=(bool)(false) ) );

}
{ //::gezi::Segmentor::get_tokens

typedef int ( *get_tokens_function_type )( ::gezi::SegHandle &,int );

Segmentor_exposer.def(
"get_tokens"
, get_tokens_function_type( &::gezi::Segmentor::get_tokens )
, ( bp::arg("handle"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::get_tokens

typedef int ( ::gezi::Segmentor::*get_tokens_function_type)( int ) ;

Segmentor_exposer.def(
"get_tokens"
, get_tokens_function_type( &::gezi::Segmentor::get_tokens )
, ( bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::handle

typedef ::gezi::SegHandle & ( *handle_function_type )( int );

Segmentor_exposer.def(
"handle"
, handle_function_type( &::gezi::Segmentor::handle )
, ( bp::arg("buf_size")=(int)(gezi::SegHandle::SEG_BUFF_SIZE) )
, bp::return_internal_reference<>());

}
{ //::gezi::Segmentor::init

typedef bool ( *init_function_type )( ::std::string,int,::std::string,bool );

Segmentor_exposer.def(
"init"
, init_function_type( &::gezi::Segmentor::init )
, ( bp::arg("data_dir")="./data/wordseg", bp::arg("type")=(int)(gezi::SEG_USE_DEFAULT), bp::arg("conf_path")="./conf/scw.conf", bp::arg("need_split_dict")=(bool)(false) ) );

}
{ //::gezi::Segmentor::ner_handle

typedef ::gezi::NerHandle & ( *ner_handle_function_type )( int );

Segmentor_exposer.def(
"ner_handle"
, ner_handle_function_type( &::gezi::Segmentor::ner_handle )
, ( bp::arg("ner_maxterm_count")=(int)(gezi::NerHandle::MAX_TERM_COUNT) )
, bp::return_internal_reference<>());

}
{ //::gezi::Segmentor::seg_words

typedef bool ( *seg_words_function_type )( ::std::string,::gezi::SegHandle & );

Segmentor_exposer.def(
"seg_words"
, seg_words_function_type( &::gezi::Segmentor::seg_words )
, ( bp::arg("input"), bp::arg("handle") ) );

}
{ //::gezi::Segmentor::segment

typedef bool ( *segment_function_type )( ::std::string,::gezi::SegHandle &,int );

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("handle"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef bool ( *segment_function_type )( ::std::string,::gezi::SegHandle &,::std::vector< std::string > &,int );

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("handle"), bp::arg("result"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef ::std::string ( *segment_function_type )( ::std::string,::gezi::SegHandle &,::std::string,int );

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("handle"), bp::arg("sep"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef ::std::vector< std::string > ( ::gezi::Segmentor::*segment_function_type)( ::std::string,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef bool ( ::gezi::Segmentor::*segment_function_type)( ::std::string,::std::vector< std::string > &,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("result"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef ::std::string ( ::gezi::Segmentor::*segment_function_type)( ::std::string,::std::string,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("sep"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef bool ( ::gezi::Segmentor::*segment_function_type)( ::std::string,::std::vector< gezi::SegNode > &,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("result"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::set_flag

typedef ::gezi::Segmentor & ( ::gezi::Segmentor::*set_flag_function_type)( int ) ;

Segmentor_exposer.def(
"set_flag"
, set_flag_function_type( &::gezi::Segmentor::set_flag )
, ( bp::arg("flag_") )
, bp::return_internal_reference<>());

}
{ //::gezi::Segmentor::uninit

typedef void ( *uninit_function_type )(  );

Segmentor_exposer.def(
"uninit"
, uninit_function_type( &::gezi::Segmentor::uninit ) );

}
Segmentor_exposer.staticmethod( "AddStrategy" );
Segmentor_exposer.staticmethod( "Cut" );
Segmentor_exposer.staticmethod( "GetNerNodes" );
Segmentor_exposer.staticmethod( "GetSegNodes" );
Segmentor_exposer.staticmethod( "GetSubNerNodes" );
Segmentor_exposer.staticmethod( "GetTokens" );
Segmentor_exposer.staticmethod( "GetWordRank" );
Segmentor_exposer.staticmethod( "Init" );
Segmentor_exposer.staticmethod( "InitThread" );
Segmentor_exposer.staticmethod( "MergeNewword" );
Segmentor_exposer.staticmethod( "NerTag" );
Segmentor_exposer.staticmethod( "NerWordRank" );
Segmentor_exposer.staticmethod( "NerWordRankMap" );
Segmentor_exposer.staticmethod( "Seg" );
Segmentor_exposer.staticmethod( "SegWords" );
Segmentor_exposer.staticmethod( "Segment" );
Segmentor_exposer.staticmethod( "Segment_" );
Segmentor_exposer.staticmethod( "SetFlag" );
Segmentor_exposer.staticmethod( "SetStrategy" );
Segmentor_exposer.staticmethod( "TagPostag" );
Segmentor_exposer.staticmethod( "Uninit" );
Segmentor_exposer.staticmethod( "UseWordNer" );
Segmentor_exposer.staticmethod( "UseWordRank" );
Segmentor_exposer.staticmethod( "WordRank" );
Segmentor_exposer.staticmethod( "WordRankMap" );
Segmentor_exposer.staticmethod( "add_strategy" );
Segmentor_exposer.staticmethod( "get_nernodes" );
Segmentor_exposer.staticmethod( "get_segnodes" );
Segmentor_exposer.staticmethod( "get_sub_nernodes" );
Segmentor_exposer.staticmethod( "get_tokens" );
Segmentor_exposer.staticmethod( "handle" );
Segmentor_exposer.staticmethod( "init" );
Segmentor_exposer.staticmethod( "ner_handle" );
Segmentor_exposer.staticmethod( "seg_words" );
Segmentor_exposer.staticmethod( "segment" );
Segmentor_exposer.staticmethod( "uninit" );
}

{ //::gezi::is_noun

typedef bool ( *is_noun_function_type )( ::size_t );

bp::def(
"is_noun"
, is_noun_function_type( &::gezi::is_noun )
, ( bp::arg("type") ) );

}

{ //::gezi::print_ner_result

typedef void ( *print_ner_result_function_type )( ::std::string,::gezi::SegHandle const &,::gezi::NerHandle const & );

bp::def(
"print_ner_result"
, print_ner_result_function_type( &::gezi::print_ner_result )
, ( bp::arg("input"), bp::arg("handle"), bp::arg("ner_handle") ) );

}

{ //::gezi::print_seg_posttag_result

typedef void ( *print_seg_posttag_result_function_type )( ::gezi::SegHandle const & );

bp::def(
"print_seg_posttag_result"
, print_seg_posttag_result_function_type( &::gezi::print_seg_posttag_result )
, ( bp::arg("handle") ) );

}

{ //::gezi::print_seg_posttag_result

typedef void ( *print_seg_posttag_result_function_type )(  );

bp::def(
"print_seg_posttag_result"
, print_seg_posttag_result_function_type( &::gezi::print_seg_posttag_result ) );

}

{ //::gezi::print_seg_result

typedef void ( *print_seg_result_function_type )( ::gezi::SegHandle const & );

bp::def(
"print_seg_result"
, print_seg_result_function_type( &::gezi::print_seg_result )
, ( bp::arg("handle") ) );

}

{ //::gezi::print_seg_result

typedef void ( *print_seg_result_function_type )(  );

bp::def(
"print_seg_result"
, print_seg_result_function_type( &::gezi::print_seg_result ) );

}

bp::scope().attr("SEG_BASIC") = gezi::SEG_BASIC;

bp::scope().attr("SEG_HUMAN_NAME") = gezi::SEG_HUMAN_NAME;

bp::scope().attr("SEG_MERGE_NEWWORD") = gezi::SEG_MERGE_NEWWORD;

bp::scope().attr("SEG_NEWWORD") = gezi::SEG_NEWWORD;

bp::scope().attr("SEG_USE_ALL") = gezi::SEG_USE_ALL;

bp::scope().attr("SEG_USE_DEFAULT") = gezi::SEG_USE_DEFAULT;

bp::scope().attr("SEG_USE_NONE") = gezi::SEG_USE_NONE;

bp::scope().attr("SEG_USE_OFFSETS") = gezi::SEG_USE_OFFSETS;

bp::scope().attr("SEG_USE_POSTAG") = gezi::SEG_USE_POSTAG;

bp::scope().attr("SEG_USE_SPLIT") = gezi::SEG_USE_SPLIT;

bp::scope().attr("SEG_USE_TRIE") = gezi::SEG_USE_TRIE;

bp::scope().attr("SEG_USE_WORDNER") = gezi::SEG_USE_WORDNER;

bp::scope().attr("SEG_USE_WORDNER_AUTO") = gezi::SEG_USE_WORDNER_AUTO;

bp::scope().attr("SEG_USE_WORDRANK") = gezi::SEG_USE_WORDRANK;

bp::scope().attr("SEG_USE_WORDRANK_AUTO") = gezi::SEG_USE_WORDRANK_AUTO;

bp::scope().attr("SEG_WPCOMP") = gezi::SEG_WPCOMP;
}
