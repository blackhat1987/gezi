#define private public
#define protected public
#include "../include/python_util.h"
// This file has been generated by Py++.

#include "boost/python.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "boost/python/suite/indexing/map_indexing_suite.hpp"

#include "../include/PythonWrapper/Predictor.h"

#include "../include/PythonWrapper/PredictorFactory.h"

#include "../include/file_util.h"

#include "../include/Numeric/collocation.h"

#include "../include/conf_util.h"

#include "../include/serialize_util.h"

#include "../include/Numeric/Vector/Vector.h"

#include "../include/Numeric/Vector/vector_util.h"

#include "../include/feature/FeatureSelector.h"

#include "../include/Identifer.h"

#include "../include/Idf.h"

#include "../include/log_util.h"

#include "../include/Segmentor.h"
const int gezi::SegHandle::SEG_BUFF_SIZE;

#include "../include/ProgressBar.h"

#include "../include/tieba/util.h"

#include "../include/tools/content_process.h"

#include "../include/string_util.h"

#include "../include/reg_util.h"

#include "../include/feature/FeatureVector.h"

#include "../include/feature/features_util.h"

#include "../include/feature/FeaturesExtractor.h"

#include "../include/feature/FeaturesExtractorMgr.h"

namespace bp = boost::python;

struct FeaturesExtractor_wrapper : gezi::FeaturesExtractor, bp::wrapper< gezi::FeaturesExtractor > {

FeaturesExtractor_wrapper(gezi::FeaturesExtractor const & arg )
: gezi::FeaturesExtractor( arg )
, bp::wrapper< gezi::FeaturesExtractor >(){
// copy constructor

}

FeaturesExtractor_wrapper(::std::string name="" )
: gezi::FeaturesExtractor( name )
, bp::wrapper< gezi::FeaturesExtractor >(){
// constructor

}

virtual void extract(  ) {
if( bp::override func_extract = this->get_override( "extract" ) )
func_extract(  );
else
this->gezi::FeaturesExtractor::extract(  );
}


void default_extract(  ) {
gezi::FeaturesExtractor::extract( );
}

virtual void init(  ) {
if( bp::override func_init = this->get_override( "init" ) )
func_init(  );
else
this->gezi::FeaturesExtractor::init(  );
}


void default_init(  ) {
gezi::FeaturesExtractor::init( );
}

virtual void process( ::gezi::Features * features ) {
if( bp::override func_process = this->get_override( "process" ) )
func_process( boost::python::ptr(features) );
else
this->gezi::FeaturesExtractor::process( boost::python::ptr(features) );
}


void default_process( ::gezi::Features * features ) {
gezi::FeaturesExtractor::process( boost::python::ptr(features) );
}

};

struct SegHandle_wrapper : gezi::SegHandle, bp::wrapper< gezi::SegHandle > {

SegHandle_wrapper(gezi::SegHandle const & arg )
: gezi::SegHandle( arg )
, bp::wrapper< gezi::SegHandle >(){
// copy constructor

}

SegHandle_wrapper( )
: gezi::SegHandle( )
, bp::wrapper< gezi::SegHandle >(){
// null constructor

}

SegHandle_wrapper(int bufsize )
: gezi::SegHandle( bufsize )
, bp::wrapper< gezi::SegHandle >(){
// constructor

}

static ::scw_out_t * get_pout(gezi::SegHandle const & inst ){
return inst.pout;
}

static void set_pout( gezi::SegHandle & inst, ::scw_out_t * new_value ){
inst.pout = new_value;
}

static ::token_t * get_tokens(gezi::SegHandle const & inst ){
return inst.tokens;
}

static void set_tokens( gezi::SegHandle & inst, ::token_t * new_value ){
inst.tokens = new_value;
}

};

BOOST_PYTHON_MODULE(libgezi){
UseStrVec;
UseIntVec;
UseFloatVec;
UseDoubleVec;
UseStrStrMap;
UseStrIntMap;
//UseStrIntHashMap;
UseStrFloatMap;
UseStrDoubleMap;

{ //::std::vector< token_t >
typedef bp::class_< std::vector< token_t > > vector_less__token_t__greater__exposer_t;
vector_less__token_t__greater__exposer_t vector_less__token_t__greater__exposer = vector_less__token_t__greater__exposer_t( "vector_less__token_t__greater_" );
bp::scope vector_less__token_t__greater__scope( vector_less__token_t__greater__exposer );
//WARNING: the next line of code will not compile, because "::token_t" does not have operator== !
//         vector_less__token_t__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< token_t > >() );
}

{ //::std::vector< std::vector< double > >
typedef bp::class_< std::vector< std::vector< double > > > vector_less__std_scope_vector_less__double__greater___greater__exposer_t;
vector_less__std_scope_vector_less__double__greater___greater__exposer_t vector_less__std_scope_vector_less__double__greater___greater__exposer = vector_less__std_scope_vector_less__double__greater___greater__exposer_t( "vector_less__std_scope_vector_less__double__greater___greater_" );
bp::scope vector_less__std_scope_vector_less__double__greater___greater__scope( vector_less__std_scope_vector_less__double__greater___greater__exposer );
//WARNING: the next line of code will not compile, because "::std::vector<double, std::allocator<double> >" does not have operator== !
//         vector_less__std_scope_vector_less__double__greater___greater__exposer.def( bp::vector_indexing_suite< ::std::vector< std::vector< double > > >() );
}

{ //::std::vector< std::string >
typedef bp::class_< std::vector< std::string > > vector_less__std_scope_string__greater__exposer_t;
vector_less__std_scope_string__greater__exposer_t vector_less__std_scope_string__greater__exposer = vector_less__std_scope_string__greater__exposer_t( "vector_less__std_scope_string__greater_" );
bp::scope vector_less__std_scope_string__greater__scope( vector_less__std_scope_string__greater__exposer );
vector_less__std_scope_string__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< std::string >, true >() );
}

{ //::std::vector< std::wstring >
typedef bp::class_< std::vector< std::wstring > > vector_less__std_scope_wstring__greater__exposer_t;
vector_less__std_scope_wstring__greater__exposer_t vector_less__std_scope_wstring__greater__exposer = vector_less__std_scope_wstring__greater__exposer_t( "vector_less__std_scope_wstring__greater_" );
bp::scope vector_less__std_scope_wstring__greater__scope( vector_less__std_scope_wstring__greater__exposer );
vector_less__std_scope_wstring__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< std::wstring >, true >() );
}

bp::class_< std::vector< std::string > >("vector_less__std_scope_string__greater_")
.def( bp::vector_indexing_suite< ::std::vector< std::string >, true >() );

bp::class_< std::vector< std::string > >("vector_less__std_scope_string__greater_")
.def( bp::vector_indexing_suite< ::std::vector< std::string >, true >() );

{ //::std::vector< int >
typedef bp::class_< std::vector< int > > vector_less__int__greater__exposer_t;
vector_less__int__greater__exposer_t vector_less__int__greater__exposer = vector_less__int__greater__exposer_t( "vector_less__int__greater_" );
bp::scope vector_less__int__greater__scope( vector_less__int__greater__exposer );
vector_less__int__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< int >, true >() );
}

{ //scope begin
typedef bp::class_< std::vector< gezi::SegNode > > vector_less__gezi_scope_SegNode__greater__exposer_t;
vector_less__gezi_scope_SegNode__greater__exposer_t vector_less__gezi_scope_SegNode__greater__exposer = vector_less__gezi_scope_SegNode__greater__exposer_t("vector_less__gezi_scope_SegNode__greater_");
bp::scope vector_less__gezi_scope_SegNode__greater__scope( vector_less__gezi_scope_SegNode__greater__exposer );
//WARNING: the next line of code will not compile, because "::gezi::SegNode" does not have operator== !
//         vector_less__gezi_scope_SegNode__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< gezi::SegNode > >() );
} //scope end

{ //::std::vector< gezi::FeaturesExtractor* >
typedef bp::class_< std::vector< gezi::FeaturesExtractor* > > vector_less__gezi_scope_FeaturesExtractor_ptr___greater__exposer_t;
vector_less__gezi_scope_FeaturesExtractor_ptr___greater__exposer_t vector_less__gezi_scope_FeaturesExtractor_ptr___greater__exposer = vector_less__gezi_scope_FeaturesExtractor_ptr___greater__exposer_t( "vector_less__gezi_scope_FeaturesExtractor_ptr___greater_" );
bp::scope vector_less__gezi_scope_FeaturesExtractor_ptr___greater__scope( vector_less__gezi_scope_FeaturesExtractor_ptr___greater__exposer );
vector_less__gezi_scope_FeaturesExtractor_ptr___greater__exposer.def( bp::vector_indexing_suite< ::std::vector< gezi::FeaturesExtractor* > >() );
}

{ //::std::vector< gezi::FeatureVector::Feature >
typedef bp::class_< std::vector< gezi::FeatureVector::Feature > > vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer_t;
vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer_t vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer = vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer_t( "vector_less__gezi_scope_FeatureVector_scope_Feature__greater_" );
bp::scope vector_less__gezi_scope_FeatureVector_scope_Feature__greater__scope( vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer );
//WARNING: the next line of code will not compile, because "::gezi::FeatureVector::Feature" does not have operator== !
//         vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< gezi::FeatureVector::Feature > >() );
}

{ //::std::vector< double >
typedef bp::class_< std::vector< double > > vector_less__double__greater__exposer_t;
vector_less__double__greater__exposer_t vector_less__double__greater__exposer = vector_less__double__greater__exposer_t( "vector_less__double__greater_" );
bp::scope vector_less__double__greater__scope( vector_less__double__greater__exposer );
vector_less__double__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< double >, true >() );
}

{ //::std::map< std::string, std::string >
typedef bp::class_< std::map< std::string, std::string > > map_less__std_scope_string_comma__std_scope_string__greater__exposer_t;
map_less__std_scope_string_comma__std_scope_string__greater__exposer_t map_less__std_scope_string_comma__std_scope_string__greater__exposer = map_less__std_scope_string_comma__std_scope_string__greater__exposer_t( "map_less__std_scope_string_comma__std_scope_string__greater_" );
bp::scope map_less__std_scope_string_comma__std_scope_string__greater__scope( map_less__std_scope_string_comma__std_scope_string__greater__exposer );
map_less__std_scope_string_comma__std_scope_string__greater__exposer.def( bp::map_indexing_suite< ::std::map< std::string, std::string >, true >() );
}

bp::enum_< gezi::collocation::Method>("Method")
.value("CHI", gezi::collocation::CHI)
.value("IG", gezi::collocation::IG)
.value("MI", gezi::collocation::MI)
.value("MI2", gezi::collocation::MI2)
.value("PMI", gezi::collocation::PMI)
.value("ECE", gezi::collocation::ECE)
.value("EMI", gezi::collocation::EMI)
.value("T_TEST", gezi::collocation::T_TEST)
.value("LIR", gezi::collocation::LIR)
.value("FREQ", gezi::collocation::FREQ)
.value("IDF", gezi::collocation::IDF)
.export_values()
;

bp::class_< gezi::ChiSquareFunc >( "ChiSquareFunc" )
.def(
"__call__"
, (::Float ( ::gezi::ChiSquareFunc::* )( int,int,int,::uint64 ) )( &::gezi::ChiSquareFunc::operator() )
, ( bp::arg("a"), bp::arg("n1"), bp::arg("n2"), bp::arg("total") ) );

bp::class_< gezi::DiscountedMutualInfoFunc >( "DiscountedMutualInfoFunc" )
.def(
"__call__"
, (::Float ( ::gezi::DiscountedMutualInfoFunc::* )( int,int,int,long long unsigned int ) )( &::gezi::DiscountedMutualInfoFunc::operator() )
, ( bp::arg("a00"), bp::arg("nterm1"), bp::arg("nterm2"), bp::arg("n") ) );

bp::class_< gezi::EChiSquareFunc >( "EChiSquareFunc" )
.def(
"__call__"
, (::Float ( ::gezi::EChiSquareFunc::* )( int,int,int,long long unsigned int ) )( &::gezi::EChiSquareFunc::operator() )
, ( bp::arg("a00"), bp::arg("nterm1"), bp::arg("nterm2"), bp::arg("n") ) );

bp::class_< gezi::EMutualInfoFunc >( "EMutualInfoFunc" )
.def(
"__call__"
, (::Float ( ::gezi::EMutualInfoFunc::* )( int,int,int,long long unsigned int ) )( &::gezi::EMutualInfoFunc::operator() )
, ( bp::arg("a00"), bp::arg("nterm1"), bp::arg("nterm2"), bp::arg("n") ) );

bp::class_< gezi::EchoFunc >( "EchoFunc" )
.def(
"__call__"
, (::Float ( ::gezi::EchoFunc::* )( int,int,int,::uint64 ) )( &::gezi::EchoFunc::operator() )
, ( bp::arg("a"), bp::arg("n1"), bp::arg("n2"), bp::arg("n") ) );

{ //::gezi::FeatureSelector
typedef bp::class_< gezi::FeatureSelector > FeatureSelector_exposer_t;
FeatureSelector_exposer_t FeatureSelector_exposer = FeatureSelector_exposer_t( "FeatureSelector", bp::init< >() );
bp::scope FeatureSelector_scope( FeatureSelector_exposer );
bp::enum_< gezi::FeatureSelector::Strategy>("Strategy")
.value("MAX", gezi::FeatureSelector::MAX)
.value("AVG", gezi::FeatureSelector::AVG)
.value("SUM", gezi::FeatureSelector::SUM)
.export_values()
;
{ //::gezi::FeatureSelector::add

typedef void ( ::gezi::FeatureSelector::*add_function_type )( ::std::vector< std::string > const &,int ) ;

FeatureSelector_exposer.def(
"add"
, add_function_type( &::gezi::FeatureSelector::add )
, ( bp::arg("words"), bp::arg("label") ) );

}
{ //::gezi::FeatureSelector::add

typedef void ( ::gezi::FeatureSelector::*add_function_type )( ::std::string,int,::std::string ) ;

FeatureSelector_exposer.def(
"add"
, add_function_type( &::gezi::FeatureSelector::add )
, ( bp::arg("doc"), bp::arg("label"), bp::arg("sep")="\011" ) );

}
{ //::gezi::FeatureSelector::calc

typedef ::gezi::dmat & ( ::gezi::FeatureSelector::*calc_function_type )(  ) ;

FeatureSelector_exposer.def(
"calc"
, calc_function_type( &::gezi::FeatureSelector::calc )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureSelector::clear

typedef void ( ::gezi::FeatureSelector::*clear_function_type )(  ) ;

FeatureSelector_exposer.def(
"clear"
, clear_function_type( &::gezi::FeatureSelector::clear ) );

}
{ //::gezi::FeatureSelector::clearScore

typedef void ( ::gezi::FeatureSelector::*clearScore_function_type )(  ) ;

FeatureSelector_exposer.def(
"clearScore"
, clearScore_function_type( &::gezi::FeatureSelector::clearScore ) );

}
{ //::gezi::FeatureSelector::featureNum

typedef int ( ::gezi::FeatureSelector::*featureNum_function_type )(  ) ;

FeatureSelector_exposer.def(
"featureNum"
, featureNum_function_type( &::gezi::FeatureSelector::featureNum ) );

}
{ //::gezi::FeatureSelector::init

typedef void ( ::gezi::FeatureSelector::*init_function_type )(  ) ;

FeatureSelector_exposer.def(
"init"
, init_function_type( &::gezi::FeatureSelector::init ) );

}
{ //::gezi::FeatureSelector::initFunc

typedef void ( ::gezi::FeatureSelector::*initFunc_function_type )(  ) ;

FeatureSelector_exposer.def(
"initFunc"
, initFunc_function_type( &::gezi::FeatureSelector::initFunc ) );

}
{ //::gezi::FeatureSelector::instanceNum

typedef ::int64 ( ::gezi::FeatureSelector::*instanceNum_function_type )(  ) ;

FeatureSelector_exposer.def(
"instanceNum"
, instanceNum_function_type( &::gezi::FeatureSelector::instanceNum ) );

}
{ //::gezi::FeatureSelector::labelNum

typedef int ( ::gezi::FeatureSelector::*labelNum_function_type )(  ) ;

FeatureSelector_exposer.def(
"labelNum"
, labelNum_function_type( &::gezi::FeatureSelector::labelNum ) );

}
{ //::gezi::FeatureSelector::labelNum

typedef ::gezi::FeatureSelector & ( ::gezi::FeatureSelector::*labelNum_function_type )( int ) ;

FeatureSelector_exposer.def(
"labelNum"
, labelNum_function_type( &::gezi::FeatureSelector::labelNum )
, ( bp::arg("labelNum") )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureSelector::method

typedef int ( ::gezi::FeatureSelector::*method_function_type )(  ) ;

FeatureSelector_exposer.def(
"method"
, method_function_type( &::gezi::FeatureSelector::method ) );

}
{ //::gezi::FeatureSelector::method

typedef ::gezi::FeatureSelector & ( ::gezi::FeatureSelector::*method_function_type )( ::gezi::collocation::Method ) ;

FeatureSelector_exposer.def(
"method"
, method_function_type( &::gezi::FeatureSelector::method )
, ( bp::arg("method") )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureSelector::minSupport

typedef int ( ::gezi::FeatureSelector::*minSupport_function_type )(  ) ;

FeatureSelector_exposer.def(
"minSupport"
, minSupport_function_type( &::gezi::FeatureSelector::minSupport ) );

}
{ //::gezi::FeatureSelector::minSupport

typedef ::gezi::FeatureSelector & ( ::gezi::FeatureSelector::*minSupport_function_type )( int ) ;

FeatureSelector_exposer.def(
"minSupport"
, minSupport_function_type( &::gezi::FeatureSelector::minSupport )
, ( bp::arg("minSupport") )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureSelector::save

typedef void ( ::gezi::FeatureSelector::*save_function_type )( ::std::string,int,int ) ;

FeatureSelector_exposer.def(
"save"
, save_function_type( &::gezi::FeatureSelector::save )
, ( bp::arg("file"), bp::arg("idx")=(int)(-0x00000000000000001), bp::arg("maxFeatureNum")=(int)(-0x00000000000000001) ) );

}
{ //::gezi::FeatureSelector::save

typedef void ( ::gezi::FeatureSelector::*save_function_type )( ::std::ostream &,int,int ) ;

FeatureSelector_exposer.def(
"save"
, save_function_type( &::gezi::FeatureSelector::save )
, ( bp::arg("os"), bp::arg("maxFeatureNum"), bp::arg("idx") ) );

}
{ //::gezi::FeatureSelector::save_all

typedef void ( ::gezi::FeatureSelector::*save_all_function_type )( ::std::string ) ;

FeatureSelector_exposer.def(
"save_all"
, save_all_function_type( &::gezi::FeatureSelector::save_all )
, ( bp::arg("dir")="result" ) );

}
{ //::gezi::FeatureSelector::save_idf

typedef void ( ::gezi::FeatureSelector::*save_idf_function_type )( ::std::string ) ;

FeatureSelector_exposer.def(
"save_idf"
, save_idf_function_type( &::gezi::FeatureSelector::save_idf )
, ( bp::arg("file") ) );

}
{ //::gezi::FeatureSelector::show

typedef void ( ::gezi::FeatureSelector::*show_function_type )( int,int ) ;

FeatureSelector_exposer.def(
"show"
, show_function_type( &::gezi::FeatureSelector::show )
, ( bp::arg("maxFeatureNum")=(int)(1024), bp::arg("idx")=(int)(-0x00000000000000001) ) );

}
{ //::gezi::FeatureSelector::strategy

typedef int ( ::gezi::FeatureSelector::*strategy_function_type )(  ) ;

FeatureSelector_exposer.def(
"strategy"
, strategy_function_type( &::gezi::FeatureSelector::strategy ) );

}
{ //::gezi::FeatureSelector::strategy

typedef ::gezi::FeatureSelector & ( ::gezi::FeatureSelector::*strategy_function_type )( ::gezi::FeatureSelector::Strategy ) ;

FeatureSelector_exposer.def(
"strategy"
, strategy_function_type( &::gezi::FeatureSelector::strategy )
, ( bp::arg("strategy") )
, bp::return_internal_reference<>());

}
}

{ //::gezi::Vector
typedef bp::class_< gezi::Vector > Vector_exposer_t;
Vector_exposer_t Vector_exposer = Vector_exposer_t( "Vector", bp::init< >() );
bp::scope Vector_scope( Vector_exposer );
Vector_exposer.def( bp::init< gezi::Vector const & >(( bp::arg("arg0") )) );
Vector_exposer.def( bp::init< int >(( bp::arg("length_") )) );
bp::implicitly_convertible< int, gezi::Vector >();
Vector_exposer.def( bp::init< int, Float >(( bp::arg("length_"), bp::arg("value_") )) );
Vector_exposer.def( bp::init< int, ivec &, Fvec & >(( bp::arg("length_"), bp::arg("indices_"), bp::arg("values_") )) );
Vector_exposer.def( bp::init< Fvec & >(( bp::arg("values_") )) );
bp::implicitly_convertible< Fvec &, gezi::Vector >();
Vector_exposer.def( bp::init< std::string, bp::optional< int, std::string > >(( bp::arg("input"), bp::arg("length_")=(int)(1024000), bp::arg("sep")=",\011 " )) );
{ //::gezi::Vector::Add

typedef void ( ::gezi::Vector::*Add_function_type )( ::Float ) ;

Vector_exposer.def(
"Add"
, Add_function_type( &::gezi::Vector::Add )
, ( bp::arg("value") ) );

}
{ //::gezi::Vector::Add

typedef void ( ::gezi::Vector::*Add_function_type )( int,::Float ) ;

Vector_exposer.def(
"Add"
, Add_function_type( &::gezi::Vector::Add )
, ( bp::arg("index"), bp::arg("value") ) );

}
{ //::gezi::Vector::Add

typedef void ( ::gezi::Vector::*Add_function_type )( ::gezi::Vector ) ;

Vector_exposer.def(
"Add"
, Add_function_type( &::gezi::Vector::Add )
, ( bp::arg("a") ) );

}
{ //::gezi::Vector::CheckInvariants

typedef void ( ::gezi::Vector::*CheckInvariants_function_type )(  ) ;

Vector_exposer.def(
"CheckInvariants"
, CheckInvariants_function_type( &::gezi::Vector::CheckInvariants ) );

}
{ //::gezi::Vector::Clear

typedef void ( ::gezi::Vector::*Clear_function_type )(  ) ;

Vector_exposer.def(
"Clear"
, Clear_function_type( &::gezi::Vector::Clear ) );

}
{ //::gezi::Vector::Count

typedef int ( ::gezi::Vector::*Count_function_type )(  ) const;

Vector_exposer.def(
"Count"
, Count_function_type( &::gezi::Vector::Count ) );

}
{ //::gezi::Vector::DenseStr

typedef ::std::string ( ::gezi::Vector::*DenseStr_function_type )( ::std::string ) ;

Vector_exposer.def(
"DenseStr"
, DenseStr_function_type( &::gezi::Vector::DenseStr )
, ( bp::arg("sep")="," ) );

}
{ //::gezi::Vector::Densify

typedef void ( ::gezi::Vector::*Densify_function_type )( ::Float ) ;

Vector_exposer.def(
"Densify"
, Densify_function_type( &::gezi::Vector::Densify )
, ( bp::arg("maxSparsity") ) );

}
{ //::gezi::Vector::Densify

typedef void ( ::gezi::Vector::*Densify_function_type )(  ) ;

Vector_exposer.def(
"Densify"
, Densify_function_type( &::gezi::Vector::Densify ) );

}
{ //::gezi::Vector::Empty

typedef bool ( ::gezi::Vector::*Empty_function_type )(  ) const;

Vector_exposer.def(
"Empty"
, Empty_function_type( &::gezi::Vector::Empty ) );

}
{ //::gezi::Vector::Index

typedef int ( ::gezi::Vector::*Index_function_type )( int ) const;

Vector_exposer.def(
"Index"
, Index_function_type( &::gezi::Vector::Index )
, ( bp::arg("index") ) );

}
{ //::gezi::Vector::Index

typedef int ( ::gezi::Vector::*Index_function_type )( int ) ;

Vector_exposer.def(
"Index"
, Index_function_type( &::gezi::Vector::Index )
, ( bp::arg("index") ) );

}
{ //::gezi::Vector::Indices

typedef ::ivec const & ( ::gezi::Vector::*Indices_function_type )(  ) const;

Vector_exposer.def(
"Indices"
, Indices_function_type( &::gezi::Vector::Indices )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::Vector::Indices

typedef ::ivec & ( ::gezi::Vector::*Indices_function_type )(  ) ;

Vector_exposer.def(
"Indices"
, Indices_function_type( &::gezi::Vector::Indices )
, bp::return_internal_reference<>());

}
{ //::gezi::Vector::Init

typedef void ( ::gezi::Vector::*Init_function_type )( int,::ivec &,::Fvec & ) ;

Vector_exposer.def(
"Init"
, Init_function_type( &::gezi::Vector::Init )
, ( bp::arg("length_"), bp::arg("indices_"), bp::arg("values_") ) );

}
{ //::gezi::Vector::Init

typedef void ( ::gezi::Vector::*Init_function_type )( ::Fvec & ) ;

Vector_exposer.def(
"Init"
, Init_function_type( &::gezi::Vector::Init )
, ( bp::arg("values_") ) );

}
{ //::gezi::Vector::IsDense

typedef bool ( ::gezi::Vector::*IsDense_function_type )(  ) const;

Vector_exposer.def(
"IsDense"
, IsDense_function_type( &::gezi::Vector::IsDense ) );

}
{ //::gezi::Vector::IsSparse

typedef bool ( ::gezi::Vector::*IsSparse_function_type )(  ) const;

Vector_exposer.def(
"IsSparse"
, IsSparse_function_type( &::gezi::Vector::IsSparse ) );

}
{ //::gezi::Vector::Length

typedef int ( ::gezi::Vector::*Length_function_type )(  ) const;

Vector_exposer.def(
"Length"
, Length_function_type( &::gezi::Vector::Length ) );

}
{ //::gezi::Vector::MakeDense

typedef void ( ::gezi::Vector::*MakeDense_function_type )(  ) ;

Vector_exposer.def(
"MakeDense"
, MakeDense_function_type( &::gezi::Vector::MakeDense ) );

}
{ //::gezi::Vector::MakeSparse

typedef void ( ::gezi::Vector::*MakeSparse_function_type )(  ) ;

Vector_exposer.def(
"MakeSparse"
, MakeSparse_function_type( &::gezi::Vector::MakeSparse ) );

}
{ //::gezi::Vector::Norm

typedef ::Float ( ::gezi::Vector::*Norm_function_type )(  ) ;

Vector_exposer.def(
"Norm"
, Norm_function_type( &::gezi::Vector::Norm ) );

}
{ //::gezi::Vector::NumNonZeros

typedef int ( ::gezi::Vector::*NumNonZeros_function_type )(  ) ;

Vector_exposer.def(
"NumNonZeros"
, NumNonZeros_function_type( &::gezi::Vector::NumNonZeros ) );

}
{ //::gezi::Vector::PrepareDense

typedef void ( ::gezi::Vector::*PrepareDense_function_type )(  ) ;

Vector_exposer.def(
"PrepareDense"
, PrepareDense_function_type( &::gezi::Vector::PrepareDense ) );

}
{ //::gezi::Vector::ScaleBy

typedef void ( ::gezi::Vector::*ScaleBy_function_type )( ::Float ) ;

Vector_exposer.def(
"ScaleBy"
, ScaleBy_function_type( &::gezi::Vector::ScaleBy )
, ( bp::arg("d") ) );

}
{ //::gezi::Vector::SetLength

typedef void ( ::gezi::Vector::*SetLength_function_type )( int ) ;

Vector_exposer.def(
"SetLength"
, SetLength_function_type( &::gezi::Vector::SetLength )
, ( bp::arg("length_") ) );

}
{ //::gezi::Vector::Sparsify

typedef void ( ::gezi::Vector::*Sparsify_function_type )( ::Float ) ;

Vector_exposer.def(
"Sparsify"
, Sparsify_function_type( &::gezi::Vector::Sparsify )
, ( bp::arg("maxSparsity") ) );

}
{ //::gezi::Vector::Sparsify

typedef void ( ::gezi::Vector::*Sparsify_function_type )(  ) ;

Vector_exposer.def(
"Sparsify"
, Sparsify_function_type( &::gezi::Vector::Sparsify ) );

}
{ //::gezi::Vector::Str

typedef ::std::string ( ::gezi::Vector::*Str_function_type )( ::std::string ) ;

Vector_exposer.def(
"Str"
, Str_function_type( &::gezi::Vector::Str )
, ( bp::arg("sep")="," ) );

}
{ //::gezi::Vector::Swap

typedef void ( ::gezi::Vector::*Swap_function_type )( ::gezi::Vector & ) ;

Vector_exposer.def(
"Swap"
, Swap_function_type( &::gezi::Vector::Swap )
, ( bp::arg("other") ) );

}
{ //::gezi::Vector::ToDense

typedef void ( ::gezi::Vector::*ToDense_function_type )( ::Fvec & ) ;

Vector_exposer.def(
"ToDense"
, ToDense_function_type( &::gezi::Vector::ToDense )
, ( bp::arg("values_") ) );

}
{ //::gezi::Vector::ToDense

typedef void ( ::gezi::Vector::*ToDense_function_type )(  ) ;

Vector_exposer.def(
"ToDense"
, ToDense_function_type( &::gezi::Vector::ToDense ) );

}
{ //::gezi::Vector::ToSparse

typedef void ( ::gezi::Vector::*ToSparse_function_type )(  ) ;

Vector_exposer.def(
"ToSparse"
, ToSparse_function_type( &::gezi::Vector::ToSparse ) );

}
{ //::gezi::Vector::Value

typedef ::Float ( ::gezi::Vector::*Value_function_type )( int ) const;

Vector_exposer.def(
"Value"
, Value_function_type( &::gezi::Vector::Value )
, ( bp::arg("index") ) );

}
{ //::gezi::Vector::Values

typedef ::Fvec const & ( ::gezi::Vector::*Values_function_type )(  ) const;

Vector_exposer.def(
"Values"
, Values_function_type( &::gezi::Vector::Values )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::Vector::Values

typedef ::Fvec & ( ::gezi::Vector::*Values_function_type )(  ) ;

Vector_exposer.def(
"Values"
, Values_function_type( &::gezi::Vector::Values )
, bp::return_internal_reference<>());

}
{ //::gezi::Vector::empty

typedef bool ( ::gezi::Vector::*empty_function_type )(  ) const;

Vector_exposer.def(
"empty"
, empty_function_type( &::gezi::Vector::empty ) );

}
{ //::gezi::Vector::operator()

typedef ::gezi::Vector & ( ::gezi::Vector::*__call___function_type )( int,::Float ) ;

Vector_exposer.def(
"__call__"
, __call___function_type( &::gezi::Vector::operator() )
, ( bp::arg("index"), bp::arg("value") )
, bp::return_internal_reference<>());

}
Vector_exposer.def( bp::self *= bp::other< Float >() );
{ //::gezi::Vector::operator=

typedef ::gezi::Vector & ( ::gezi::Vector::*assign_function_type )( ::gezi::Vector const & ) ;

Vector_exposer.def(
"assign"
, assign_function_type( &::gezi::Vector::operator= )
, ( bp::arg("arg0") )
, bp::return_self< >() );

}
{ //::gezi::Vector::operator[]

typedef ::Float ( ::gezi::Vector::*__getitem___function_type )( int ) const;

Vector_exposer.def(
"__getitem__"
, __getitem___function_type( &::gezi::Vector::operator[] )
, ( bp::arg("i") ) );

}
{ //::gezi::Vector::operator[]

typedef ::Float & ( ::gezi::Vector::*__getitem___function_type )( int ) ;

Vector_exposer.def(
"__getitem__"
, __getitem___function_type( &::gezi::Vector::operator[] )
, ( bp::arg("i") )
, bp::return_value_policy< bp::copy_non_const_reference >() );

}
{ //::gezi::Vector::size

typedef int ( ::gezi::Vector::*size_function_type )(  ) const;

Vector_exposer.def(
"size"
, size_function_type( &::gezi::Vector::size ) );

}
{ //::gezi::Vector::str

typedef ::std::string ( ::gezi::Vector::*str_function_type )( ::std::string ) ;

Vector_exposer.def(
"str"
, str_function_type( &::gezi::Vector::str )
, ( bp::arg("sep")="," ) );

}
Vector_exposer.def_readwrite( "indices", &gezi::Vector::indices );
Vector_exposer.def_readwrite( "keepDense", &gezi::Vector::keepDense );
Vector_exposer.def_readwrite( "keepSparse", &gezi::Vector::keepSparse );
Vector_exposer.def_readwrite( "normalized", &gezi::Vector::normalized );
Vector_exposer.def_readwrite( "numNonZeros", &gezi::Vector::numNonZeros );
Vector_exposer.def_readwrite( "sparsityRatio", &gezi::Vector::sparsityRatio );
Vector_exposer.def_readwrite( "values", &gezi::Vector::values );
}

{ //::gezi::FeatureVector
typedef bp::class_< gezi::FeatureVector, bp::bases< gezi::Vector > > FeatureVector_exposer_t;
FeatureVector_exposer_t FeatureVector_exposer = FeatureVector_exposer_t( "FeatureVector", bp::init< gezi::FeatureVector const & >(( bp::arg("arg0") )) );
bp::scope FeatureVector_scope( FeatureVector_exposer );
{ //::gezi::FeatureVector::Feature
typedef bp::class_< gezi::FeatureVector::Feature > Feature_exposer_t;
Feature_exposer_t Feature_exposer = Feature_exposer_t( "Feature", bp::init< >() );
bp::scope Feature_scope( Feature_exposer );
Feature_exposer.def( bp::init< int, Float >(( bp::arg("index_"), bp::arg("value_") )) );
Feature_exposer.def( bp::init< int >(( bp::arg("index_") )) );
bp::implicitly_convertible< int, gezi::FeatureVector::Feature >();
Feature_exposer.def_readwrite( "index", &gezi::FeatureVector::Feature::index );
Feature_exposer.def_readwrite( "value", &gezi::FeatureVector::Feature::value );
}
FeatureVector_exposer.def( bp::init< bp::optional< bool > >(( bp::arg("useSparse")=(bool)(true) )) );
bp::implicitly_convertible< bool, gezi::FeatureVector >();
FeatureVector_exposer.def( bp::init< int >(( bp::arg("length_") )) );
bp::implicitly_convertible< int, gezi::FeatureVector >();
{ //::gezi::FeatureVector::add

typedef void ( ::gezi::FeatureVector::*add_function_type )( ::Float,::std::string ) ;

FeatureVector_exposer.def(
"add"
, add_function_type( &::gezi::FeatureVector::add )
, ( bp::arg("value"), bp::arg("name")="" ) );

}
{ //::gezi::FeatureVector::add

typedef void ( ::gezi::FeatureVector::*add_function_type )( ::Float *,int,::std::string ) ;

FeatureVector_exposer.def(
"add"
, add_function_type( &::gezi::FeatureVector::add )
, ( bp::arg("values_"), bp::arg("len"), bp::arg("name")="" ) );

}
{ //::gezi::FeatureVector::add

typedef void ( ::gezi::FeatureVector::*add_function_type )( int,::Float ) ;

FeatureVector_exposer.def(
"add"
, add_function_type( &::gezi::FeatureVector::add )
, ( bp::arg("index"), bp::arg("value") ) );

}
{ //::gezi::FeatureVector::add_section

typedef void ( ::gezi::FeatureVector::*add_section_function_type )( ::std::string ) ;

FeatureVector_exposer.def(
"add_section"
, add_section_function_type( &::gezi::FeatureVector::add_section )
, ( bp::arg("name") ) );

}
{ //::gezi::FeatureVector::at

typedef ::Float ( ::gezi::FeatureVector::*at_function_type )( int ) const;

FeatureVector_exposer.def(
"at"
, at_function_type( &::gezi::FeatureVector::at )
, ( bp::arg("index") ) );

}
{ //::gezi::FeatureVector::count

typedef int ( ::gezi::FeatureVector::*count_function_type )(  ) ;

FeatureVector_exposer.def(
"count"
, count_function_type( &::gezi::FeatureVector::count ) );

}
{ //::gezi::FeatureVector::dimension

typedef int ( ::gezi::FeatureVector::*dimension_function_type )(  ) const;

FeatureVector_exposer.def(
"dimension"
, dimension_function_type( &::gezi::FeatureVector::dimension ) );

}
{ //::gezi::FeatureVector::empty

typedef bool ( ::gezi::FeatureVector::*empty_function_type )(  ) const;

FeatureVector_exposer.def(
"empty"
, empty_function_type( &::gezi::FeatureVector::empty ) );

}
{ //::gezi::FeatureVector::features

typedef ::std::vector< gezi::FeatureVector::Feature > & ( ::gezi::FeatureVector::*features_function_type )(  ) ;

FeatureVector_exposer.def(
"features"
, features_function_type( &::gezi::FeatureVector::features )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureVector::features

typedef ::std::vector< gezi::FeatureVector::Feature > const & ( ::gezi::FeatureVector::*features_function_type )(  ) const;

FeatureVector_exposer.def(
"features"
, features_function_type( &::gezi::FeatureVector::features )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::FeatureVector::finalize

typedef void ( ::gezi::FeatureVector::*finalize_function_type )(  ) ;

FeatureVector_exposer.def(
"finalize"
, finalize_function_type( &::gezi::FeatureVector::finalize ) );

}
{ //::gezi::FeatureVector::name_counts

typedef ::std::vector< int > & ( ::gezi::FeatureVector::*name_counts_function_type )(  ) ;

FeatureVector_exposer.def(
"name_counts"
, name_counts_function_type( &::gezi::FeatureVector::name_counts )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureVector::name_counts

typedef ::std::vector< int > const & ( ::gezi::FeatureVector::*name_counts_function_type )(  ) const;

FeatureVector_exposer.def(
"name_counts"
, name_counts_function_type( &::gezi::FeatureVector::name_counts )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::FeatureVector::names

typedef ::std::vector< std::string > & ( ::gezi::FeatureVector::*names_function_type )(  ) ;

FeatureVector_exposer.def(
"names"
, names_function_type( &::gezi::FeatureVector::names )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureVector::names

typedef ::std::vector< std::string > const & ( ::gezi::FeatureVector::*names_function_type )(  ) const;

FeatureVector_exposer.def(
"names"
, names_function_type( &::gezi::FeatureVector::names )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::FeatureVector::operator=

typedef ::gezi::FeatureVector & ( ::gezi::FeatureVector::*assign_function_type )( ::gezi::FeatureVector const & ) ;

FeatureVector_exposer.def(
"assign"
, assign_function_type( &::gezi::FeatureVector::operator= )
, ( bp::arg("arg0") )
, bp::return_self< >() );

}
{ //::gezi::FeatureVector::operator[]

typedef ::Float ( ::gezi::FeatureVector::*__getitem___function_type )( int ) const;

FeatureVector_exposer.def(
"__getitem__"
, __getitem___function_type( &::gezi::FeatureVector::operator[] )
, ( bp::arg("i") ) );

}
{ //::gezi::FeatureVector::operator[]

typedef ::Float ( ::gezi::FeatureVector::*__getitem___function_type )( int ) ;

FeatureVector_exposer.def(
"__getitem__"
, __getitem___function_type( &::gezi::FeatureVector::operator[] )
, ( bp::arg("i") ) );

}
{ //::gezi::FeatureVector::section_names

typedef ::std::vector< std::string > & ( ::gezi::FeatureVector::*section_names_function_type )(  ) ;

FeatureVector_exposer.def(
"section_names"
, section_names_function_type( &::gezi::FeatureVector::section_names )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureVector::section_names

typedef ::std::vector< std::string > const & ( ::gezi::FeatureVector::*section_names_function_type )(  ) const;

FeatureVector_exposer.def(
"section_names"
, section_names_function_type( &::gezi::FeatureVector::section_names )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::FeatureVector::str

typedef ::std::string ( ::gezi::FeatureVector::*str_function_type )( ::std::string ) ;

FeatureVector_exposer.def(
"str"
, str_function_type( &::gezi::FeatureVector::str )
, ( bp::arg("sep")="," ) );

}
{ //::gezi::FeatureVector::value_at

typedef ::Float ( ::gezi::FeatureVector::*value_at_function_type )( int ) const;

FeatureVector_exposer.def(
"value_at"
, value_at_function_type( &::gezi::FeatureVector::value_at )
, ( bp::arg("index") ) );

}
}

{ //::gezi::FeaturesExtractor
typedef bp::class_< FeaturesExtractor_wrapper > FeaturesExtractor_exposer_t;
FeaturesExtractor_exposer_t FeaturesExtractor_exposer = FeaturesExtractor_exposer_t( "FeaturesExtractor", bp::init< bp::optional< std::string > >(( bp::arg("name")="" )) );
bp::scope FeaturesExtractor_scope( FeaturesExtractor_exposer );
bp::implicitly_convertible< std::string, gezi::FeaturesExtractor >();
{ //::gezi::FeaturesExtractor::add

typedef void ( ::gezi::FeaturesExtractor::*add_function_type )( double,::std::string ) ;

FeaturesExtractor_exposer.def(
"add"
, add_function_type( &::gezi::FeaturesExtractor::add )
, ( bp::arg("value"), bp::arg("name")="" ) );

}
{ //::gezi::FeaturesExtractor::add

typedef void ( ::gezi::FeaturesExtractor::*add_function_type )( double *,int,::std::string ) ;

FeaturesExtractor_exposer.def(
"add"
, add_function_type( &::gezi::FeaturesExtractor::add )
, ( bp::arg("values"), bp::arg("n"), bp::arg("name")="" ) );

}
{ //::gezi::FeaturesExtractor::bind

typedef void ( ::gezi::FeaturesExtractor::*bind_function_type )( ::gezi::Features * ) ;

FeaturesExtractor_exposer.def(
"bind"
, bind_function_type( &::gezi::FeaturesExtractor::bind )
, ( bp::arg("features") ) );

}
{ //::gezi::FeaturesExtractor::extract

typedef void ( ::gezi::FeaturesExtractor::*extract_function_type )(  ) ;
typedef void ( FeaturesExtractor_wrapper::*default_extract_function_type )(  ) ;

FeaturesExtractor_exposer.def(
"extract"
, extract_function_type(&::gezi::FeaturesExtractor::extract)
, default_extract_function_type(&FeaturesExtractor_wrapper::default_extract) );

}
{ //::gezi::FeaturesExtractor::feature

typedef ::gezi::Features * ( ::gezi::FeaturesExtractor::*feature_function_type )(  ) ;

FeaturesExtractor_exposer.def(
"feature"
, feature_function_type( &::gezi::FeaturesExtractor::feature )
, bp::return_internal_reference<>());

}
{ //::gezi::FeaturesExtractor::features

typedef ::gezi::Features * ( ::gezi::FeaturesExtractor::*features_function_type )(  ) ;

FeaturesExtractor_exposer.def(
"features"
, features_function_type( &::gezi::FeaturesExtractor::features )
, bp::return_internal_reference<>());

}
{ //::gezi::FeaturesExtractor::init

typedef void ( ::gezi::FeaturesExtractor::*init_function_type )(  ) ;
typedef void ( FeaturesExtractor_wrapper::*default_init_function_type )(  ) ;

FeaturesExtractor_exposer.def(
"init"
, init_function_type(&::gezi::FeaturesExtractor::init)
, default_init_function_type(&FeaturesExtractor_wrapper::default_init) );

}
{ //::gezi::FeaturesExtractor::name

typedef ::std::string ( ::gezi::FeaturesExtractor::*name_function_type )(  ) ;

FeaturesExtractor_exposer.def(
"name"
, name_function_type( &::gezi::FeaturesExtractor::name ) );

}
{ //::gezi::FeaturesExtractor::process

typedef void ( ::gezi::FeaturesExtractor::*process_function_type )( ::gezi::Features * ) ;
typedef void ( FeaturesExtractor_wrapper::*default_process_function_type )( ::gezi::Features * ) ;

FeaturesExtractor_exposer.def(
"process"
, process_function_type(&::gezi::FeaturesExtractor::process)
, default_process_function_type(&FeaturesExtractor_wrapper::default_process)
, ( bp::arg("features") ) );

}
}

bp::class_< gezi::FeaturesExtractorMgr >( "FeaturesExtractorMgr" )
.def(
"add"
, (void ( ::gezi::FeaturesExtractorMgr::* )( ::gezi::FeaturesExtractor * ) )( &::gezi::FeaturesExtractorMgr::add )
, ( bp::arg("extractor") ) )
.def(
"extract"
, (void ( ::gezi::FeaturesExtractorMgr::* )( ::gezi::Features & ) )( &::gezi::FeaturesExtractorMgr::extract )
, ( bp::arg("features") ) )
.def(
"extract"
, (void ( ::gezi::FeaturesExtractorMgr::* )( ::gezi::Features * ) )( &::gezi::FeaturesExtractorMgr::extract )
, ( bp::arg("features") ) )
.def(
"extractor"
, (::gezi::FeaturesExtractor * ( ::gezi::FeaturesExtractorMgr::* )(  ) )( &::gezi::FeaturesExtractorMgr::extractor )
, bp::return_internal_reference<>())
.def(
"extractors"
, (::std::vector< gezi::FeaturesExtractor* > & ( ::gezi::FeaturesExtractorMgr::* )(  ) )( &::gezi::FeaturesExtractorMgr::extractors )
, bp::return_internal_reference<>())
.def(
"extractors"
, (::std::vector< gezi::FeaturesExtractor* > const & ( ::gezi::FeaturesExtractorMgr::* )(  ) const)( &::gezi::FeaturesExtractorMgr::extractors )
, bp::return_value_policy< bp::copy_const_reference >() );

bp::class_< gezi::Identifer >( "Identifer" )
.def(
"Load"
, (void ( ::gezi::Identifer::* )( ::std::string ) )( &::gezi::Identifer::Load )
, ( bp::arg("path") ) )
.def(
"Save"
, (void ( ::gezi::Identifer::* )( ::std::string ) )( &::gezi::Identifer::Save )
, ( bp::arg("path") ) )
.def(
"add"
, (int ( ::gezi::Identifer::* )( ::std::string ) )( &::gezi::Identifer::add )
, ( bp::arg("f") ) )
.def(
"add"
, (int ( ::gezi::Identifer::* )( ::std::string,bool & ) )( &::gezi::Identifer::add )
, ( bp::arg("f"), bp::arg("isnew") ) )
.def(
"add_unique"
, (int ( ::gezi::Identifer::* )( ::std::string ) )( &::gezi::Identifer::add_unique )
, ( bp::arg("f") ) )
.def(
"clear"
, (void ( ::gezi::Identifer::* )(  ) )( &::gezi::Identifer::clear ) )
.def(
"empty"
, (bool ( ::gezi::Identifer::* )(  ) const)( &::gezi::Identifer::empty ) )
.def(
"has"
, (bool ( ::gezi::Identifer::* )( ::std::string ) const)( &::gezi::Identifer::has )
, ( bp::arg("f") ) )
.def(
"id"
, (int ( ::gezi::Identifer::* )( ::std::string ) const)( &::gezi::Identifer::id )
, ( bp::arg("f") ) )
.def(
"key"
, (::std::string ( ::gezi::Identifer::* )( int ) const)( &::gezi::Identifer::key )
, ( bp::arg("id") ) )
.def(
"keys"
, (::std::vector< std::string > & ( ::gezi::Identifer::* )(  ) )( &::gezi::Identifer::keys )
, bp::return_internal_reference<>())
.def(
"last"
, (::std::string ( ::gezi::Identifer::* )(  ) )( &::gezi::Identifer::last ) )
.def(
"load"
, (bool ( ::gezi::Identifer::* )( ::std::string,::std::string ) )( &::gezi::Identifer::load )
, ( bp::arg("file"), bp::arg("sep")="\011" ) )
.def(
"null_id"
, (int const (*)(  ))( &::gezi::Identifer::null_id ) )
.def(
"__call__"
, (int const & ( ::gezi::Identifer::* )( ::std::string ) const)( &::gezi::Identifer::operator() )
, ( bp::arg("key") )
, bp::return_value_policy< bp::copy_const_reference >() )
.def(
"__getitem__"
, (::std::string ( ::gezi::Identifer::* )( int ) const)( &::gezi::Identifer::operator[] )
, ( bp::arg("id") ) )
.def(
"save"
, (void ( ::gezi::Identifer::* )( ::std::string ) )( &::gezi::Identifer::save )
, ( bp::arg("file") ) )
.def(
"size"
, (::size_t ( ::gezi::Identifer::* )(  ) const)( &::gezi::Identifer::size ) )
.def(
"words"
, (::std::vector< std::string > & ( ::gezi::Identifer::* )(  ) )( &::gezi::Identifer::words )
, bp::return_internal_reference<>())
.staticmethod( "null_id" );

bp::class_< gezi::Idf >( "Idf", bp::init< >() )
.def(
"add"
, (void ( ::gezi::Idf::* )( ::std::string,::std::string ) )( &::gezi::Idf::add )
, ( bp::arg("doc"), bp::arg("sep")="\011" ) )
.def(
"add"
, (void ( ::gezi::Idf::* )( ::std::vector< std::string > const & ) )( &::gezi::Idf::add )
, ( bp::arg("words") ) )
.def(
"save"
, (void ( ::gezi::Idf::* )( ::std::string ) )( &::gezi::Idf::save )
, ( bp::arg("file") ) )
.def(
"show"
, (void ( ::gezi::Idf::* )( int ) )( &::gezi::Idf::show )
, ( bp::arg("maxNum")=(int)(1024) ) );

bp::class_< gezi::LogEChiSquareFunc >( "LogEChiSquareFunc" )
.def(
"__call__"
, (::Float ( ::gezi::LogEChiSquareFunc::* )( int,int,int,long long unsigned int ) )( &::gezi::LogEChiSquareFunc::operator() )
, ( bp::arg("a00"), bp::arg("nterm1"), bp::arg("nterm2"), bp::arg("n") ) );

{ //::gezi::LogHelper
typedef bp::class_< gezi::LogHelper > LogHelper_exposer_t;
LogHelper_exposer_t LogHelper_exposer = LogHelper_exposer_t( "LogHelper", bp::init< bp::optional< int > >(( bp::arg("log_level")=(int)(16) )) );
bp::scope LogHelper_scope( LogHelper_exposer );
bp::implicitly_convertible< int, gezi::LogHelper >();
LogHelper_exposer.def( bp::init< bool >(( bp::arg("with_conf") )) );
bp::implicitly_convertible< bool, gezi::LogHelper >();
LogHelper_exposer.def( bp::init< std::string const &, std::string const & >(( bp::arg("conf_path"), bp::arg("conf_file") )) );
{ //::gezi::LogHelper::set_level

typedef void ( *set_level_function_type )( int );

LogHelper_exposer.def(
"set_level"
, set_level_function_type( &::gezi::LogHelper::set_level )
, ( bp::arg("log_level") ) );

}
LogHelper_exposer.staticmethod( "set_level" );
}

bp::class_< gezi::NoProgressBar >( "NoProgressBar" )
.def(
"__call__"
, (void ( ::gezi::NoProgressBar::* )( ::size_t,::size_t ) const)( &::gezi::NoProgressBar::operator() )
, ( bp::arg("arg0"), bp::arg("arg1") ) );

bp::class_< gezi::PointMutualInfoFunc >( "PointMutualInfoFunc" )
.def(
"__call__"
, (::Float ( ::gezi::PointMutualInfoFunc::* )( int,int,int,::uint64 ) )( &::gezi::PointMutualInfoFunc::operator() )
, ( bp::arg("a"), bp::arg("n1"), bp::arg("n2"), bp::arg("n") ) );

{ //::gezi::ProgressBar
typedef bp::class_< gezi::ProgressBar > ProgressBar_exposer_t;
ProgressBar_exposer_t ProgressBar_exposer = ProgressBar_exposer_t( "ProgressBar", bp::init< >() );
bp::scope ProgressBar_scope( ProgressBar_exposer );
ProgressBar_exposer.def( bp::init< std::string >(( bp::arg("log_word") )) );
bp::implicitly_convertible< std::string, gezi::ProgressBar >();
ProgressBar_exposer.def( bp::init< size_t >(( bp::arg("total") )) );
bp::implicitly_convertible< size_t, gezi::ProgressBar >();
ProgressBar_exposer.def( bp::init< std::string, size_t >(( bp::arg("log_word"), bp::arg("total") )) );
ProgressBar_exposer.def( bp::init< size_t, std::string >(( bp::arg("total"), bp::arg("log_word") )) );
{ //::gezi::ProgressBar::operator()

typedef void ( ::gezi::ProgressBar::*__call___function_type )( ::size_t ) ;

ProgressBar_exposer.def(
"__call__"
, __call___function_type( &::gezi::ProgressBar::operator() )
, ( bp::arg("current") ) );

}
{ //::gezi::ProgressBar::operator()

typedef void ( ::gezi::ProgressBar::*__call___function_type )( ::size_t,::size_t ) ;

ProgressBar_exposer.def(
"__call__"
, __call___function_type( &::gezi::ProgressBar::operator() )
, ( bp::arg("current"), bp::arg("total") ) );

}
ProgressBar_exposer.def( bp::self += bp::other< size_t >() );
{ //::gezi::ProgressBar::progress

typedef void ( ::gezi::ProgressBar::*progress_function_type )( ::size_t ) ;

ProgressBar_exposer.def(
"progress"
, progress_function_type( &::gezi::ProgressBar::progress )
, ( bp::arg("current") ) );

}
{ //::gezi::ProgressBar::progress

typedef void ( ::gezi::ProgressBar::*progress_function_type )( ::size_t,::size_t ) ;

ProgressBar_exposer.def(
"progress"
, progress_function_type( &::gezi::ProgressBar::progress )
, ( bp::arg("current"), bp::arg("total") ) );

}
}

bp::class_< gezi::ValueIdentifer< double >, bp::bases< gezi::Identifer > >( "DoubleIdentifer" )
.def(
"Load"
, (void ( ::gezi::ValueIdentifer<double>::* )( ::std::string ) )( &::gezi::ValueIdentifer< double >::Load )
, ( bp::arg("file") ) )
.def(
"Save"
, (void ( ::gezi::ValueIdentifer<double>::* )( ::std::string ) )( &::gezi::ValueIdentifer< double >::Save )
, ( bp::arg("file") ) )
.def(
"get_value"
, (double ( ::gezi::ValueIdentifer<double>::* )( ::std::string ) )( &::gezi::ValueIdentifer< double >::get_value )
, ( bp::arg("key") ) )
.def(
"load"
, (bool ( ::gezi::ValueIdentifer<double>::* )( ::std::string,int,::std::string ) )( &::gezi::ValueIdentifer< double >::load )
, ( bp::arg("file"), bp::arg("index")=(int)(1), bp::arg("sep")="\011" ) )
.def(
"value"
, (double ( ::gezi::ValueIdentifer<double>::* )( int ) )( &::gezi::ValueIdentifer< double >::value )
, ( bp::arg("index") ) );

bp::class_< gezi::PyDoubleIdentifer, bp::bases< gezi::ValueIdentifer< double > > >( "PyDoubleIdentifer" );

bp::class_< gezi::PyFeatures, bp::bases< gezi::FeatureVector > >( "PyFeatures" );

bp::class_< gezi::ValueIdentifer< int >, bp::bases< gezi::Identifer > >( "IntIdentifer" )
.def(
"Load"
, (void ( ::gezi::ValueIdentifer<int>::* )( ::std::string ) )( &::gezi::ValueIdentifer< int >::Load )
, ( bp::arg("file") ) )
.def(
"Save"
, (void ( ::gezi::ValueIdentifer<int>::* )( ::std::string ) )( &::gezi::ValueIdentifer< int >::Save )
, ( bp::arg("file") ) )
.def(
"get_value"
, (int ( ::gezi::ValueIdentifer<int>::* )( ::std::string ) )( &::gezi::ValueIdentifer< int >::get_value )
, ( bp::arg("key") ) )
.def(
"load"
, (bool ( ::gezi::ValueIdentifer<int>::* )( ::std::string,int,::std::string ) )( &::gezi::ValueIdentifer< int >::load )
, ( bp::arg("file"), bp::arg("index")=(int)(1), bp::arg("sep")="\011" ) )
.def(
"value"
, (int ( ::gezi::ValueIdentifer<int>::* )( int ) )( &::gezi::ValueIdentifer< int >::value )
, ( bp::arg("index") ) );

bp::class_< gezi::PyIntIndentifer, bp::bases< gezi::ValueIdentifer< int > > >( "PyIntIndentifer" );

bp::class_< gezi::PyPredictor >( "PyPredictor" )
.def(
"Normalize"
, (::gezi::Vector ( ::gezi::PyPredictor::* )( ::gezi::Vector & ) )( &::gezi::PyPredictor::Normalize )
, ( bp::arg("features") ) )
.def(
"Output"
, (::Float ( ::gezi::PyPredictor::* )( ::gezi::Vector & ) )( &::gezi::PyPredictor::Output )
, ( bp::arg("features") ) )
.def(
"Predict"
, (::Float ( ::gezi::PyPredictor::* )( ::gezi::Vector & ) )( &::gezi::PyPredictor::Predict )
, ( bp::arg("features") ) )
.def(
"Predict"
, (::Float ( ::gezi::PyPredictor::* )( ::gezi::Vector &,::Float & ) )( &::gezi::PyPredictor::Predict )
, ( bp::arg("features"), bp::arg("output") ) );

bp::class_< gezi::PyPredictorFactory >( "PyPredictorFactory" )
.def(
"LoadPredictor"
, (::gezi::PyPredictor (*)( ::std::string ))( &::gezi::PyPredictorFactory::LoadPredictor )
, ( bp::arg("path") ) )
.staticmethod( "LoadPredictor" );

{ //::gezi::SegHandle
typedef bp::class_< SegHandle_wrapper > SegHandle_exposer_t;
SegHandle_exposer_t SegHandle_exposer = SegHandle_exposer_t( "SegHandle", bp::init< >() );
bp::scope SegHandle_scope( SegHandle_exposer );
SegHandle_exposer.def( bp::init< int >(( bp::arg("bufsize") )) );
bp::implicitly_convertible< int, gezi::SegHandle >();
{ //::gezi::SegHandle::clear

typedef void ( ::gezi::SegHandle::*clear_function_type )(  ) ;

SegHandle_exposer.def(
"clear"
, clear_function_type( &::gezi::SegHandle::clear ) );

}
{ //::gezi::SegHandle::init

typedef void ( ::gezi::SegHandle::*init_function_type )( int ) ;

SegHandle_exposer.def(
"init"
, init_function_type( &::gezi::SegHandle::init )
, ( bp::arg("buf_size_")=(int)(gezi::SegHandle::SEG_BUFF_SIZE) ) );

}
SegHandle_exposer.def_readonly( "SEG_BUFF_SIZE", gezi::SegHandle::SEG_BUFF_SIZE );
SegHandle_exposer.def_readwrite( "buf_size", &gezi::SegHandle::buf_size );
SegHandle_exposer.def_readwrite( "nresult", &gezi::SegHandle::nresult );
SegHandle_exposer.add_property( "pout"
, bp::make_function( (::scw_out_t * (*)( ::gezi::SegHandle const & ))(&SegHandle_wrapper::get_pout), bp::return_internal_reference< >() )
, bp::make_function( (void (*)( ::gezi::SegHandle &,::scw_out_t * ))(&SegHandle_wrapper::set_pout), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
SegHandle_exposer.def_readwrite( "token_vec", &gezi::SegHandle::token_vec );
SegHandle_exposer.add_property( "tokens"
, bp::make_function( (::token_t * (*)( ::gezi::SegHandle const & ))(&SegHandle_wrapper::get_tokens), bp::return_internal_reference< >() )
, bp::make_function( (void (*)( ::gezi::SegHandle &,::token_t * ))(&SegHandle_wrapper::set_tokens), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
}

bp::class_< gezi::SegNode >( "SegNode", bp::init< >() )
.def( bp::init< std::string, int, int, int >(( bp::arg("word_"), bp::arg("length_"), bp::arg("offset_"), bp::arg("weight_") )) )
.def_readwrite( "length", &gezi::SegNode::length )
.def_readwrite( "offset", &gezi::SegNode::offset )
.def_readwrite( "weight", &gezi::SegNode::weight )
.def_readwrite( "word", &gezi::SegNode::word );

{ //::gezi::Segmentor
typedef bp::class_< gezi::Segmentor > Segmentor_exposer_t;
Segmentor_exposer_t Segmentor_exposer = Segmentor_exposer_t( "Segmentor", bp::init< bp::optional< int > >(( bp::arg("seg_buff_size")=(int)(gezi::SegHandle::SEG_BUFF_SIZE) )) );
bp::scope Segmentor_scope( Segmentor_exposer );
bp::implicitly_convertible< int, gezi::Segmentor >();
{ //::gezi::Segmentor::get_segnodes

typedef ::std::vector< gezi::SegNode > ( *get_segnodes_function_type )( ::gezi::SegHandle & );

Segmentor_exposer.def(
"get_segnodes"
, get_segnodes_function_type( &::gezi::Segmentor::get_segnodes )
, ( bp::arg("handle") ) );

}
{ //::gezi::Segmentor::get_segnodes

typedef ::std::vector< gezi::SegNode > ( ::gezi::Segmentor::*get_segnodes_function_type )(  ) ;

Segmentor_exposer.def(
"get_segnodes"
, get_segnodes_function_type( &::gezi::Segmentor::get_segnodes ) );

}
{ //::gezi::Segmentor::get_tokens

typedef int ( *get_tokens_function_type )( ::gezi::SegHandle &,int );

Segmentor_exposer.def(
"get_tokens"
, get_tokens_function_type( &::gezi::Segmentor::get_tokens )
, ( bp::arg("handle"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::get_tokens

typedef int ( ::gezi::Segmentor::*get_tokens_function_type )( int ) ;

Segmentor_exposer.def(
"get_tokens"
, get_tokens_function_type( &::gezi::Segmentor::get_tokens )
, ( bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::handle

typedef ::gezi::SegHandle & ( ::gezi::Segmentor::*handle_function_type )(  ) ;

Segmentor_exposer.def(
"handle"
, handle_function_type( &::gezi::Segmentor::handle )
, bp::return_internal_reference<>());

}
{ //::gezi::Segmentor::init

typedef bool ( *init_function_type )( ::std::string,int,::std::string );

Segmentor_exposer.def(
"init"
, init_function_type( &::gezi::Segmentor::init )
, ( bp::arg("data_dir")="./data/wordseg", bp::arg("type")=(int)(gezi::SEG_USE_DEFAULT), bp::arg("conf_path")="./conf/scw.conf" ) );

}
{ //::gezi::Segmentor::seg_words

typedef bool ( ::gezi::Segmentor::*seg_words_function_type )( ::std::string,::gezi::SegHandle & ) ;

Segmentor_exposer.def(
"seg_words"
, seg_words_function_type( &::gezi::Segmentor::seg_words )
, ( bp::arg("input"), bp::arg("handle") ) );

}
{ //::gezi::Segmentor::segment

typedef bool ( ::gezi::Segmentor::*segment_function_type )( ::std::string,::gezi::SegHandle &,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("handle"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef bool ( ::gezi::Segmentor::*segment_function_type )( ::std::string,::gezi::SegHandle &,::std::vector< std::string > &,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("handle"), bp::arg("result"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef ::std::string ( ::gezi::Segmentor::*segment_function_type )( ::std::string,::gezi::SegHandle &,::std::string,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("handle"), bp::arg("sep"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef ::std::vector< std::string > ( ::gezi::Segmentor::*segment_function_type )( ::std::string,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef bool ( ::gezi::Segmentor::*segment_function_type )( ::std::string,::std::vector< std::string > &,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("result"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef ::std::string ( ::gezi::Segmentor::*segment_function_type )( ::std::string,::std::string,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("sep"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::segment

typedef bool ( ::gezi::Segmentor::*segment_function_type )( ::std::string,::std::vector< gezi::SegNode > &,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("result"), bp::arg("type")=(int)(gezi::SEG_WPCOMP) ) );

}
{ //::gezi::Segmentor::set_buff_size

typedef ::gezi::Segmentor & ( ::gezi::Segmentor::*set_buff_size_function_type )( int ) ;

Segmentor_exposer.def(
"set_buff_size"
, set_buff_size_function_type( &::gezi::Segmentor::set_buff_size )
, ( bp::arg("buff_size") )
, bp::return_internal_reference<>());

}
{ //::gezi::Segmentor::set_flag

typedef ::gezi::Segmentor & ( ::gezi::Segmentor::*set_flag_function_type )( int ) ;

Segmentor_exposer.def(
"set_flag"
, set_flag_function_type( &::gezi::Segmentor::set_flag )
, ( bp::arg("flag") )
, bp::return_internal_reference<>());

}
{ //::gezi::Segmentor::uninit

typedef void ( *uninit_function_type )(  );

Segmentor_exposer.def(
"uninit"
, uninit_function_type( &::gezi::Segmentor::uninit ) );

}
Segmentor_exposer.staticmethod( "get_segnodes" );
Segmentor_exposer.staticmethod( "get_tokens" );
Segmentor_exposer.staticmethod( "init" );
Segmentor_exposer.staticmethod( "uninit" );
}

bp::class_< gezi::SharedConf >( "SharedConf" )
.def(
"conf"
, (::comcfg::Configure & (*)(  ))( &::gezi::SharedConf::conf )
, bp::return_internal_reference<>())
.def(
"get_conf"
, (::comcfg::Configure & (*)(  ))( &::gezi::SharedConf::get_conf )
, bp::return_internal_reference<>())
.def(
"init"
, (bool (*)( ::std::string,::std::string ))( &::gezi::SharedConf::init )
, ( bp::arg("config_file")="strategy.conf", bp::arg("dir")="./conf" ) )
.def(
"instance"
, (::comcfg::Configure * (*)(  ))( &::gezi::SharedConf::instance )
, bp::return_internal_reference<>())
.staticmethod( "conf" )
.staticmethod( "get_conf" )
.staticmethod( "init" )
.staticmethod( "instance" );

bp::class_< gezi::TTestFunc >( "TTestFunc" )
.def(
"__call__"
, (::Float ( ::gezi::TTestFunc::* )( int,int,int,long long unsigned int ) )( &::gezi::TTestFunc::operator() )
, ( bp::arg("a00"), bp::arg("nterm1"), bp::arg("nterm2"), bp::arg("n") ) );

bp::class_< gezi::ThreadLogHelper >( "ThreadLogHelper", bp::init< >() );

{ //::gezi::Vec2dWriter
typedef bp::class_< gezi::Vec2dWriter, boost::noncopyable > Vec2dWriter_exposer_t;
Vec2dWriter_exposer_t Vec2dWriter_exposer = Vec2dWriter_exposer_t( "Vec2dWriter", bp::init< std::string const & >(( bp::arg("file") )) );
bp::scope Vec2dWriter_scope( Vec2dWriter_exposer );
bp::implicitly_convertible< std::string const &, gezi::Vec2dWriter >();
{ //::gezi::Vec2dWriter::close

typedef void ( ::gezi::Vec2dWriter::*close_function_type )(  ) ;

Vec2dWriter_exposer.def(
"close"
, close_function_type( &::gezi::Vec2dWriter::close ) );

}
}

{ //::gezi::VecWriter
typedef bp::class_< gezi::VecWriter, boost::noncopyable > VecWriter_exposer_t;
VecWriter_exposer_t VecWriter_exposer = VecWriter_exposer_t( "VecWriter", bp::init< std::string const & >(( bp::arg("file") )) );
bp::scope VecWriter_scope( VecWriter_exposer );
bp::implicitly_convertible< std::string const &, gezi::VecWriter >();
{ //::gezi::VecWriter::close

typedef void ( ::gezi::VecWriter::*close_function_type )(  ) ;

VecWriter_exposer.def(
"close"
, close_function_type( &::gezi::VecWriter::close ) );

}
}

{ //::gezi::all_en

typedef bool ( *all_en_function_type )( ::std::string );

bp::def(
"all_en"
, all_en_function_type( &::gezi::all_en )
, ( bp::arg("phrase") ) );

}

{ //::gezi::chi_square

typedef ::Float ( *chi_square_function_type )( int,int,int,::uint64 );

bp::def(
"chi_square"
, chi_square_function_type( &::gezi::chi_square )
, ( bp::arg("a"), bp::arg("n1"), bp::arg("n2"), bp::arg("total") ) );

}

{ //::gezi::conf_trim

typedef ::std::string ( *conf_trim_function_type )( ::std::string );

bp::def(
"conf_trim"
, conf_trim_function_type( &::gezi::conf_trim )
, ( bp::arg("input") ) );

}

{ //::gezi::contains

typedef bool ( *contains_function_type )( ::std::string,::std::string );

bp::def(
"contains"
, contains_function_type( &::gezi::contains )
, ( bp::arg("input"), bp::arg("part") ) );

}

{ //::gezi::contains

typedef bool ( *contains_function_type )( ::std::string,char );

bp::def(
"contains"
, contains_function_type( &::gezi::contains )
, ( bp::arg("input"), bp::arg("part") ) );

}

{ //::gezi::copy_file

typedef void ( *copy_file_function_type )( ::std::string,::std::string );

bp::def(
"copy_file"
, copy_file_function_type( &::gezi::copy_file )
, ( bp::arg("src"), bp::arg("dest") ) );

}

{ //::gezi::cross_entropy

typedef ::Float ( *cross_entropy_function_type )( int,int,int,::uint64 );

bp::def(
"cross_entropy"
, cross_entropy_function_type( &::gezi::cross_entropy )
, ( bp::arg("nfc"), bp::arg("nf"), bp::arg("nc"), bp::arg("n") ) );

}

{ //::gezi::dot

typedef ::Float ( *dot_function_type )( ::gezi::Vector const &,::gezi::Vector const & );

bp::def(
"dot"
, dot_function_type( &::gezi::dot )
, ( bp::arg("l"), bp::arg("r") ) );

}

{ //::gezi::endswith

typedef bool ( *endswith_function_type )( ::std::string,::std::string );

bp::def(
"endswith"
, endswith_function_type( &::gezi::endswith )
, ( bp::arg("input"), bp::arg("part") ) );

}

{ //::gezi::erase

typedef ::std::string ( *erase_function_type )( ::std::string,::std::string );

bp::def(
"erase"
, erase_function_type( &::gezi::erase )
, ( bp::arg("content"), bp::arg("chars") ) );

}

{ //::gezi::extract_chinese

typedef ::std::string ( *extract_chinese_function_type )( ::std::string );

bp::def(
"extract_chinese"
, extract_chinese_function_type( &::gezi::extract_chinese )
, ( bp::arg("temp") ) );

}

{ //::gezi::extract_suspect_symb

typedef ::std::string ( *extract_suspect_symb_function_type )( ::std::string );

bp::def(
"extract_suspect_symb"
, extract_suspect_symb_function_type( &::gezi::extract_suspect_symb )
, ( bp::arg("temp") ) );

}

{ //::gezi::filter_str

typedef ::std::string ( *filter_str_function_type )( ::std::string );

bp::def(
"filter_str"
, filter_str_function_type( &::gezi::filter_str )
, ( bp::arg("temp") ) );

}

{ //::gezi::gbk_substr

typedef ::std::string ( *gbk_substr_function_type )( ::std::string,int,::size_t );

bp::def(
"gbk_substr"
, gbk_substr_function_type( &::gezi::gbk_substr )
, ( bp::arg("input"), bp::arg("start_"), bp::arg("len")=(long unsigned int)(std::basic_string<char, std::char_traits<char>, std::allocator<char> >::npos) ) );

}

{ //::gezi::get_real_title

typedef ::std::string ( *get_real_title_function_type )( ::std::string );

bp::def(
"get_real_title"
, get_real_title_function_type( &::gezi::get_real_title )
, ( bp::arg("title") ) );

}

{ //::gezi::get_val

typedef void ( *get_val_function_type )( ::comcfg::Configure const &,char *,::std::string,::std::string,::std::string );

bp::def(
"get_val"
, get_val_function_type( &::gezi::get_val )
, ( bp::arg("conf"), bp::arg("dest"), bp::arg("field"), bp::arg("key"), bp::arg("default_val") ) );

}

{ //::gezi::get_val

typedef void ( *get_val_function_type )( ::comcfg::Configure const &,char *,::std::string,::std::string );

bp::def(
"get_val"
, get_val_function_type( &::gezi::get_val )
, ( bp::arg("conf"), bp::arg("dest"), bp::arg("key"), bp::arg("default_val") ) );

}

{ //::gezi::get_val

typedef double ( *get_val_function_type )( ::comcfg::Configure const &,::std::string,::std::string,double );

bp::def(
"get_val"
, get_val_function_type( &::gezi::get_val )
, ( bp::arg("conf"), bp::arg("field"), bp::arg("key"), bp::arg("default_val") ) );

}

{ //::gezi::get_val

typedef double ( *get_val_function_type )( ::comcfg::Configure const &,::std::string,double );

bp::def(
"get_val"
, get_val_function_type( &::gezi::get_val )
, ( bp::arg("conf"), bp::arg("key"), bp::arg("default_val") ) );

}

{ //::gezi::get_val

typedef long long int ( *get_val_function_type )( ::comcfg::Configure const &,::std::string,::std::string &,long long int );

bp::def(
"get_val"
, get_val_function_type( &::gezi::get_val )
, ( bp::arg("conf"), bp::arg("field"), bp::arg("key"), bp::arg("default_val") ) );

}

{ //::gezi::get_val

typedef long long int ( *get_val_function_type )( ::comcfg::Configure const &,::std::string,long long int );

bp::def(
"get_val"
, get_val_function_type( &::gezi::get_val )
, ( bp::arg("conf"), bp::arg("key"), bp::arg("default_val") ) );

}

{ //::gezi::get_val

typedef int ( *get_val_function_type )( ::comcfg::Configure const &,::std::string,::std::string,int );

bp::def(
"get_val"
, get_val_function_type( &::gezi::get_val )
, ( bp::arg("conf"), bp::arg("field"), bp::arg("key"), bp::arg("default_val") ) );

}

{ //::gezi::get_val

typedef int ( *get_val_function_type )( ::comcfg::Configure const &,::std::string,int );

bp::def(
"get_val"
, get_val_function_type( &::gezi::get_val )
, ( bp::arg("conf"), bp::arg("key"), bp::arg("default_val") ) );

}

{ //::gezi::get_val

typedef ::std::string ( *get_val_function_type )( ::comcfg::Configure const &,::std::string,::std::string,::std::string );

bp::def(
"get_val"
, get_val_function_type( &::gezi::get_val )
, ( bp::arg("conf"), bp::arg("field"), bp::arg("key"), bp::arg("default_val") ) );

}

{ //::gezi::get_val

typedef ::std::string ( *get_val_function_type )( ::comcfg::Configure const &,::std::string,::std::string );

bp::def(
"get_val"
, get_val_function_type( &::gezi::get_val )
, ( bp::arg("conf"), bp::arg("key"), bp::arg("default_val") ) );

}

{ //::gezi::get_words

typedef ::std::vector< std::string > ( *get_words_function_type )( ::std::vector< std::string > &,int,::std::string );

bp::def(
"get_words"
, get_words_function_type( &::gezi::get_words )
, ( bp::arg("l"), bp::arg("ngram")=(int)(3), bp::arg("sep")="$#$" ) );

}

{ //::gezi::information_gain

typedef ::Float ( *information_gain_function_type )( int,int,int,::uint64 );

bp::def(
"information_gain"
, information_gain_function_type( &::gezi::information_gain )
, ( bp::arg("nfc"), bp::arg("nf"), bp::arg("nc"), bp::arg("n") ) );

}

{ //::gezi::is_alpha_only

typedef bool ( *is_alpha_only_function_type )( ::std::string );

bp::def(
"is_alpha_only"
, is_alpha_only_function_type( &::gezi::is_alpha_only )
, ( bp::arg("input") ) );

}

{ //::gezi::is_en_dominate

typedef bool ( *is_en_dominate_function_type )( ::std::string,int );

bp::def(
"is_en_dominate"
, is_en_dominate_function_type( &::gezi::is_en_dominate )
, ( bp::arg("phrase"), bp::arg("var")=(int)(3) ) );

}

{ //::gezi::is_gb2312

typedef bool ( *is_gb2312_function_type )( unsigned char,unsigned char );

bp::def(
"is_gb2312"
, is_gb2312_function_type( &::gezi::is_gb2312 )
, ( bp::arg("ch1"), bp::arg("ch2") ) );

}

{ //::gezi::is_gbk_ch

typedef bool ( *is_gbk_ch_function_type )( ::std::string );

bp::def(
"is_gbk_ch"
, is_gbk_ch_function_type( &::gezi::is_gbk_ch )
, ( bp::arg("phrase") ) );

}

{ //::gezi::is_gbk_ch

typedef bool ( *is_gbk_ch_function_type )( unsigned char,unsigned char );

bp::def(
"is_gbk_ch"
, is_gbk_ch_function_type( &::gezi::is_gbk_ch )
, ( bp::arg("ch1"), bp::arg("ch2") ) );

}

{ //::gezi::is_thread

typedef bool ( *is_thread_function_type )( ::std::string );

bp::def(
"is_thread"
, is_thread_function_type( &::gezi::is_thread )
, ( bp::arg("title") ) );

}

{ //::gezi::libsvm_normalize

typedef void ( *libsvm_normalize_function_type )( ::std::string & );

bp::def(
"libsvm_normalize"
, libsvm_normalize_function_type( &::gezi::libsvm_normalize )
, ( bp::arg("feature_str") ) );

}

{ //::gezi::max

typedef ::std::string ( *max_function_type )( ::std::string,int );

bp::def(
"max"
, max_function_type( &::gezi::max )
, ( bp::arg("input"), bp::arg("length") ) );

}

{ //::gezi::mutual_info

typedef ::Float ( *mutual_info_function_type )( int,int,int,::uint64 );

bp::def(
"mutual_info"
, mutual_info_function_type( &::gezi::mutual_info )
, ( bp::arg("nfc"), bp::arg("nf"), bp::arg("nc"), bp::arg("n") ) );

}

{ //::gezi::mutual_info2

typedef ::Float ( *mutual_info2_function_type )( int,int,int,::uint64 );

bp::def(
"mutual_info2"
, mutual_info2_function_type( &::gezi::mutual_info2 )
, ( bp::arg("nfc"), bp::arg("nf"), bp::arg("nc"), bp::arg("n") ) );

}

{ //::gezi::normalize_str

typedef ::std::string ( *normalize_str_function_type )( ::std::string );

bp::def(
"normalize_str"
, normalize_str_function_type( &::gezi::normalize_str )
, ( bp::arg("input") ) );

}

{ //::gezi::parse_bool_param

typedef bool ( *parse_bool_param_function_type )( ::std::string,::std::string );

bp::def(
"parse_bool_param"
, parse_bool_param_function_type( &::gezi::parse_bool_param )
, ( bp::arg("name"), bp::arg("line") ) );

}

{ //::gezi::parse_double_param

typedef double ( *parse_double_param_function_type )( ::std::string,::std::string );

bp::def(
"parse_double_param"
, parse_double_param_function_type( &::gezi::parse_double_param )
, ( bp::arg("name"), bp::arg("line") ) );

}

{ //::gezi::parse_int_param

typedef int ( *parse_int_param_function_type )( ::std::string,::std::string );

bp::def(
"parse_int_param"
, parse_int_param_function_type( &::gezi::parse_int_param )
, ( bp::arg("name"), bp::arg("line") ) );

}

{ //::gezi::parse_string_param

typedef ::std::string ( *parse_string_param_function_type )( ::std::string,::std::string );

bp::def(
"parse_string_param"
, parse_string_param_function_type( &::gezi::parse_string_param )
, ( bp::arg("name"), bp::arg("line") ) );

}

{ //::gezi::point_mutual_info

typedef ::Float ( *point_mutual_info_function_type )( int,int,int,::uint64 );

bp::def(
"point_mutual_info"
, point_mutual_info_function_type( &::gezi::point_mutual_info )
, ( bp::arg("a"), bp::arg("n1"), bp::arg("n2"), bp::arg("n") ) );

}

{ //::gezi::print_seg_result

typedef void ( *print_seg_result_function_type )( ::gezi::SegHandle const & );

bp::def(
"print_seg_result"
, print_seg_result_function_type( &::gezi::print_seg_result )
, ( bp::arg("handle") ) );

}

{ //::gezi::read_file

typedef ::std::string ( *read_file_function_type )( ::std::string const & );

bp::def(
"read_file"
, read_file_function_type( &::gezi::read_file )
, ( bp::arg("infile") ) );

}

{ //::gezi::read_lines

typedef void ( *read_lines_function_type )( ::std::string,::std::vector< std::string > & );

bp::def(
"read_lines"
, read_lines_function_type( &::gezi::read_lines )
, ( bp::arg("infile"), bp::arg("vec") ) );

}

{ //::gezi::read_lines

typedef ::std::vector< std::string > ( *read_lines_function_type )( ::std::string const & );

bp::def(
"read_lines"
, read_lines_function_type( &::gezi::read_lines )
, ( bp::arg("infile") ) );

}

{ //::gezi::read_lines

typedef void ( *read_lines_function_type )( ::std::string,::std::vector< std::string > & );

bp::def(
"read_lines"
, read_lines_function_type( &::gezi::read_lines )
, ( bp::arg("infile"), bp::arg("vec") ) );

}

{ //::gezi::read_lines

typedef ::std::vector< std::string > ( *read_lines_function_type )( ::std::string const & );

bp::def(
"read_lines"
, read_lines_function_type( &::gezi::read_lines )
, ( bp::arg("infile") ) );

}

{ //::gezi::read_map

typedef void ( *read_map_function_type )( ::std::string const &,::std::unordered_map< std::basic_string< char, std::char_traits< char >, std::allocator< char > >, std::basic_string< char, std::char_traits< char >, std::allocator< char > >, boost::hash< std::basic_string< char, std::char_traits< char >, std::allocator< char > > >, std::equal_to< std::basic_string< char, std::char_traits< char >, std::allocator< char > > >, std::allocator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, std::basic_string< char, std::char_traits< char >, std::allocator< char > > > > > &,::std::string,int,int );

bp::def(
"read_map"
, read_map_function_type( &::gezi::read_map )
, ( bp::arg("infile"), bp::arg("container"), bp::arg("sep")="\011", bp::arg("key_idx")=(int)(0), bp::arg("value_idx")=(int)(1) ) );

}

{ //::gezi::read_map

typedef void ( *read_map_function_type )( ::std::string const &,::std::map< std::string, std::string > &,::std::string,int,int );

bp::def(
"read_map"
, read_map_function_type( &::gezi::read_map )
, ( bp::arg("infile"), bp::arg("container"), bp::arg("sep")="\011", bp::arg("key_idx")=(int)(0), bp::arg("value_idx")=(int)(1) ) );

}

{ //::gezi::read_to_set

typedef void ( *read_to_set_function_type )( ::std::string const &,::std::unordered_set< std::basic_string< char, std::char_traits< char >, std::allocator< char > >, boost::hash< std::basic_string< char, std::char_traits< char >, std::allocator< char > > >, std::equal_to< std::basic_string< char, std::char_traits< char >, std::allocator< char > > >, std::allocator< std::basic_string< char, std::char_traits< char >, std::allocator< char > > > > &,int,::std::string );

bp::def(
"read_to_set"
, read_to_set_function_type( &::gezi::read_to_set )
, ( bp::arg("infile"), bp::arg("container"), bp::arg("index")=(int)(0), bp::arg("sep")="\011 " ) );

}

{ //::gezi::read_to_set

typedef void ( *read_to_set_function_type )( ::std::string const &,::std::set< std::string > &,int,::std::string );

bp::def(
"read_to_set"
, read_to_set_function_type( &::gezi::read_to_set )
, ( bp::arg("infile"), bp::arg("container"), bp::arg("index")=(int)(0), bp::arg("sep")="\011 " ) );

}

{ //::gezi::read_to_vec

typedef void ( *read_to_vec_function_type )( ::std::string const &,::std::vector< std::string > &,int,::std::string );

bp::def(
"read_to_vec"
, read_to_vec_function_type( &::gezi::read_to_vec )
, ( bp::arg("infile"), bp::arg("container"), bp::arg("index")=(int)(0), bp::arg("sep")="\011 " ) );

}

{ //::gezi::read_to_vec

typedef void ( *read_to_vec_function_type )( ::std::string const &,::std::vector< std::string > &,int,::std::string );

bp::def(
"read_to_vec"
, read_to_vec_function_type( &::gezi::read_to_vec )
, ( bp::arg("infile"), bp::arg("container"), bp::arg("index")=(int)(0), bp::arg("sep")="\011 " ) );

}

{ //::gezi::reg_find

typedef bool ( *reg_find_function_type )( ::std::string const &,::std::string );

bp::def(
"reg_find"
, reg_find_function_type( &::gezi::reg_find )
, ( bp::arg("content"), bp::arg("pattern") ) );

}

{ //::gezi::reg_remove

typedef ::std::wstring ( *reg_remove_function_type )( ::std::wstring const &,::std::wstring );

bp::def(
"reg_remove"
, reg_remove_function_type( &::gezi::reg_remove )
, ( bp::arg("input"), bp::arg("pattern") ) );

}

{ //::gezi::reg_remove

typedef ::std::string ( *reg_remove_function_type )( ::std::string const &,::std::string );

bp::def(
"reg_remove"
, reg_remove_function_type( &::gezi::reg_remove )
, ( bp::arg("input"), bp::arg("pattern") ) );

}

{ //::gezi::reg_replace

typedef ::std::wstring ( *reg_replace_function_type )( ::std::wstring const &,::std::wstring,::std::wstring );

bp::def(
"reg_replace"
, reg_replace_function_type( &::gezi::reg_replace )
, ( bp::arg("input"), bp::arg("pattern"), bp::arg("replacement")="\000\000\000" ) );

}

{ //::gezi::reg_replace

typedef ::std::string ( *reg_replace_function_type )( ::std::string const &,::std::string,::std::string );

bp::def(
"reg_replace"
, reg_replace_function_type( &::gezi::reg_replace )
, ( bp::arg("input"), bp::arg("pattern"), bp::arg("replacement")="" ) );

}

{ //::gezi::ufo::reg_search

typedef ::std::vector< std::wstring > ( *reg_search_function_type )( ::std::wstring const &,::boost::wregex &,int );

bp::def(
"reg_search"
, reg_search_function_type( &::gezi::ufo::reg_search )
, ( bp::arg("content"), bp::arg("reg"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::ufo::reg_search

typedef ::std::vector< std::string > ( *reg_search_function_type )( ::std::string const &,::std::string,int );

bp::def(
"reg_search"
, reg_search_function_type( &::gezi::ufo::reg_search )
, ( bp::arg("content"), bp::arg("pattern"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::ufo::reg_search

typedef ::std::vector< std::string > ( *reg_search_function_type )( ::std::string const &,::boost::regex &,int );

bp::def(
"reg_search"
, reg_search_function_type( &::gezi::ufo::reg_search )
, ( bp::arg("content"), bp::arg("reg"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::reg_search

typedef void ( *reg_search_function_type )( ::std::wstring const &,::std::wstring,::std::vector< std::wstring > &,int );

bp::def(
"reg_search"
, reg_search_function_type( &::gezi::reg_search )
, ( bp::arg("content"), bp::arg("pattern"), bp::arg("result"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::reg_search

typedef ::std::wstring ( *reg_search_function_type )( ::std::wstring const &,::std::wstring,int );

bp::def(
"reg_search"
, reg_search_function_type( &::gezi::reg_search )
, ( bp::arg("content"), bp::arg("pattern"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::reg_search

typedef void ( *reg_search_function_type )( ::std::string const &,::std::string,::std::vector< std::string > &,int );

bp::def(
"reg_search"
, reg_search_function_type( &::gezi::reg_search )
, ( bp::arg("content"), bp::arg("pattern"), bp::arg("result"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::reg_search

typedef ::std::string ( *reg_search_function_type )( ::std::string const &,::std::string,int );

bp::def(
"reg_search"
, reg_search_function_type( &::gezi::reg_search )
, ( bp::arg("content"), bp::arg("pattern"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::reg_search

typedef void ( *reg_search_function_type )( ::std::wstring const &,::boost::wregex &,::std::vector< std::wstring > &,int );

bp::def(
"reg_search"
, reg_search_function_type( &::gezi::reg_search )
, ( bp::arg("content"), bp::arg("reg"), bp::arg("result"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::reg_search

typedef ::std::wstring ( *reg_search_function_type )( ::std::wstring const &,::boost::wregex &,int );

bp::def(
"reg_search"
, reg_search_function_type( &::gezi::reg_search )
, ( bp::arg("content"), bp::arg("reg"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::reg_search

typedef void ( *reg_search_function_type )( ::std::string const &,::boost::regex &,::std::vector< std::string > &,int );

bp::def(
"reg_search"
, reg_search_function_type( &::gezi::reg_search )
, ( bp::arg("content"), bp::arg("reg"), bp::arg("result"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::reg_search

typedef ::std::string ( *reg_search_function_type )( ::std::string const &,::boost::regex &,int );

bp::def(
"reg_search"
, reg_search_function_type( &::gezi::reg_search )
, ( bp::arg("content"), bp::arg("reg"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::reg_split

typedef ::std::vector< std::wstring > ( *reg_split_function_type )( ::std::wstring const &,::std::wstring );

bp::def(
"reg_split"
, reg_split_function_type( &::gezi::reg_split )
, ( bp::arg("input"), bp::arg("pattern") ) );

}

{ //::gezi::reg_split

typedef ::std::vector< std::string > ( *reg_split_function_type )( ::std::string const &,::std::string );

bp::def(
"reg_split"
, reg_split_function_type( &::gezi::reg_split )
, ( bp::arg("input"), bp::arg("pattern") ) );

}

{ //::gezi::remove_dupspace

typedef ::std::string ( *remove_dupspace_function_type )( ::std::string );

bp::def(
"remove_dupspace"
, remove_dupspace_function_type( &::gezi::remove_dupspace )
, ( bp::arg("input") ) );

}

{ //::gezi::remove_space_cn

typedef ::std::string ( *remove_space_cn_function_type )( ::std::string );

bp::def(
"remove_space_cn"
, remove_space_cn_function_type( &::gezi::remove_space_cn )
, ( bp::arg("phrase") ) );

}

{ //::gezi::remove_space_cnonly

typedef ::std::string ( *remove_space_cnonly_function_type )( ::std::string );

bp::def(
"remove_space_cnonly"
, remove_space_cnonly_function_type( &::gezi::remove_space_cnonly )
, ( bp::arg("phrase") ) );

}

{ //::gezi::replace

typedef ::std::string ( *replace_function_type )( ::std::string,char,char );

bp::def(
"replace"
, replace_function_type( &::gezi::replace )
, ( bp::arg("input"), bp::arg("a"), bp::arg("b") ) );

}

{ //::gezi::replace_special_whitespace

typedef ::std::string ( *replace_special_whitespace_function_type )( ::std::string,char const );

bp::def(
"replace_special_whitespace"
, replace_special_whitespace_function_type( &::gezi::replace_special_whitespace )
, ( bp::arg("s"), bp::arg("rep")=(char const)(' ') ) );

}

{ //::gezi::set_val

typedef void ( *set_val_function_type )( ::comcfg::Configure const &,::std::string,::std::string,double & );

bp::def(
"set_val"
, set_val_function_type( &::gezi::set_val )
, ( bp::arg("conf"), bp::arg("field"), bp::arg("key"), bp::arg("val") ) );

}

{ //::gezi::set_val

typedef void ( *set_val_function_type )( ::comcfg::Configure const &,::std::string,double & );

bp::def(
"set_val"
, set_val_function_type( &::gezi::set_val )
, ( bp::arg("conf"), bp::arg("key"), bp::arg("val") ) );

}

{ //::gezi::set_val

typedef void ( *set_val_function_type )( ::comcfg::Configure const &,::std::string,::std::string &,long long int & );

bp::def(
"set_val"
, set_val_function_type( &::gezi::set_val )
, ( bp::arg("conf"), bp::arg("field"), bp::arg("key"), bp::arg("val") ) );

}

{ //::gezi::set_val

typedef void ( *set_val_function_type )( ::comcfg::Configure const &,::std::string,long long int & );

bp::def(
"set_val"
, set_val_function_type( &::gezi::set_val )
, ( bp::arg("conf"), bp::arg("key"), bp::arg("val") ) );

}

{ //::gezi::set_val

typedef void ( *set_val_function_type )( ::comcfg::Configure const &,::std::string,::std::string,bool & );

bp::def(
"set_val"
, set_val_function_type( &::gezi::set_val )
, ( bp::arg("conf"), bp::arg("field"), bp::arg("key"), bp::arg("val") ) );

}

{ //::gezi::set_val

typedef void ( *set_val_function_type )( ::comcfg::Configure const &,::std::string,bool & );

bp::def(
"set_val"
, set_val_function_type( &::gezi::set_val )
, ( bp::arg("conf"), bp::arg("key"), bp::arg("val") ) );

}

{ //::gezi::set_val

typedef void ( *set_val_function_type )( ::comcfg::Configure const &,::std::string,::std::string,int & );

bp::def(
"set_val"
, set_val_function_type( &::gezi::set_val )
, ( bp::arg("conf"), bp::arg("field"), bp::arg("key"), bp::arg("val") ) );

}

{ //::gezi::set_val

typedef void ( *set_val_function_type )( ::comcfg::Configure const &,::std::string,int & );

bp::def(
"set_val"
, set_val_function_type( &::gezi::set_val )
, ( bp::arg("conf"), bp::arg("key"), bp::arg("val") ) );

}

{ //::gezi::set_val

typedef void ( *set_val_function_type )( ::comcfg::Configure const &,::std::string,::std::string,::std::string & );

bp::def(
"set_val"
, set_val_function_type( &::gezi::set_val )
, ( bp::arg("conf"), bp::arg("field"), bp::arg("key"), bp::arg("val") ) );

}

{ //::gezi::set_val

typedef void ( *set_val_function_type )( ::comcfg::Configure const &,::std::string,::std::string & );

bp::def(
"set_val"
, set_val_function_type( &::gezi::set_val )
, ( bp::arg("conf"), bp::arg("key"), bp::arg("val") ) );

}

{ //::gezi::startswith

typedef bool ( *startswith_function_type )( ::std::string,char );

bp::def(
"startswith"
, startswith_function_type( &::gezi::startswith )
, ( bp::arg("input"), bp::arg("part") ) );

}

{ //::gezi::startswith

typedef bool ( *startswith_function_type )( ::std::string,::std::string );

bp::def(
"startswith"
, startswith_function_type( &::gezi::startswith )
, ( bp::arg("input"), bp::arg("part") ) );

}

{ //::gezi::str_replace_all

typedef ::std::string ( *str_replace_all_function_type )( ::std::string,::std::string,::std::string );

bp::def(
"str_replace_all"
, str_replace_all_function_type( &::gezi::str_replace_all )
, ( bp::arg("tstr"), bp::arg("old_value"), bp::arg("new_value") ) );

}

{ //::gezi::strip_html

typedef ::std::string ( *strip_html_function_type )( ::std::string );

bp::def(
"strip_html"
, strip_html_function_type( &::gezi::strip_html )
, ( bp::arg("src") ) );

}

{ //::gezi::to_cnvec

typedef ::std::vector< std::string > ( *to_cnvec_function_type )( ::std::string );

bp::def(
"to_cnvec"
, to_cnvec_function_type( &::gezi::to_cnvec )
, ( bp::arg("line") ) );

}

{ //::gezi::to_features

typedef ::gezi::Vector ( *to_features_function_type )( ::std::string );

bp::def(
"to_features"
, to_features_function_type( &::gezi::to_features )
, ( bp::arg("sparseFeatureStr") ) );

}

{ //::gezi::to_identifer_map

typedef ::std::unordered_map< std::basic_string< char, std::char_traits< char >, std::allocator< char > >, int, boost::hash< std::basic_string< char, std::char_traits< char >, std::allocator< char > > >, std::equal_to< std::basic_string< char, std::char_traits< char >, std::allocator< char > > >, std::allocator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, int > > > ( *to_identifer_map_function_type )( ::std::string,int );

bp::def(
"to_identifer_map"
, to_identifer_map_function_type( &::gezi::to_identifer_map )
, ( bp::arg("infile"), bp::arg("start")=(int)(0) ) );

}

{ //::gezi::to_identifer_map

typedef ::std::unordered_map< std::string, int, boost::hash< std::string >, std::equal_to< std::string >, std::allocator< std::pair< std::string const, int > > > ( *to_identifer_map_function_type )( ::std::string,int );

bp::def(
"to_identifer_map"
, to_identifer_map_function_type( &::gezi::to_identifer_map )
, ( bp::arg("infile"), bp::arg("start")=(int)(0) ) );

}

{ //::gezi::to_set

typedef ::std::set< std::string > ( *to_set_function_type )( ::std::string );

bp::def(
"to_set"
, to_set_function_type( &::gezi::to_set )
, ( bp::arg("infile") ) );

}

{ //::gezi::to_uset

typedef ::std::unordered_set< std::basic_string< char, std::char_traits< char >, std::allocator< char > >, boost::hash< std::basic_string< char, std::char_traits< char >, std::allocator< char > > >, std::equal_to< std::basic_string< char, std::char_traits< char >, std::allocator< char > > >, std::allocator< std::basic_string< char, std::char_traits< char >, std::allocator< char > > > > ( *to_uset_function_type )( ::std::string );

bp::def(
"to_uset"
, to_uset_function_type( &::gezi::to_uset )
, ( bp::arg("infile") ) );

}

{ //::gezi::try_create_dir

typedef void ( *try_create_dir_function_type )( ::std::string );

bp::def(
"try_create_dir"
, try_create_dir_function_type( &::gezi::try_create_dir )
, ( bp::arg("dir") ) );

}

{ //::gezi::wchar_count

typedef int ( *wchar_count_function_type )( char const *,int );

bp::def(
"wchar_count"
, wchar_count_function_type( &::gezi::wchar_count )
, ( bp::arg("buf"), bp::arg("len") ) );

}

{ //::gezi::word_count

typedef int ( *word_count_function_type )( ::std::string );

bp::def(
"word_count"
, word_count_function_type( &::gezi::word_count )
, ( bp::arg("phrase") ) );

}

{ //::gezi::ufo::wreg_search

typedef ::std::vector< std::wstring > ( *wreg_search_function_type )( ::std::wstring const &,::std::wstring,int );

bp::def(
"wreg_search"
, wreg_search_function_type( &::gezi::ufo::wreg_search )
, ( bp::arg("content"), bp::arg("pattern"), bp::arg("index")=(int)(1) ) );

}

{ //::gezi::write_arff

typedef void ( *write_arff_function_type )( ::gezi::Features const &,::std::string,::std::string,::std::ostream & );

bp::def(
"write_arff"
, write_arff_function_type( &::gezi::write_arff )
, ( bp::arg("features"), bp::arg("uid"), bp::arg("type"), bp::arg("ofs") ) );

}

{ //::gezi::write_def

typedef void ( *write_def_function_type )( ::gezi::Features const &,::std::string );

bp::def(
"write_def"
, write_def_function_type( &::gezi::write_def )
, ( bp::arg("features"), bp::arg("outfile") ) );

}

{ //::gezi::write_file

typedef void ( *write_file_function_type )( ::std::string,::std::string );

bp::def(
"write_file"
, write_file_function_type( &::gezi::write_file )
, ( bp::arg("content"), bp::arg("outfile") ) );

}

{ //::gezi::write_header

typedef void ( *write_header_function_type )( ::gezi::Features const &,::std::string );

bp::def(
"write_header"
, write_header_function_type( &::gezi::write_header )
, ( bp::arg("features"), bp::arg("file") ) );

}

{ //::gezi::write_header

typedef void ( *write_header_function_type )( ::gezi::Features const &,::std::ostream & );

bp::def(
"write_header"
, write_header_function_type( &::gezi::write_header )
, ( bp::arg("features"), bp::arg("ofs") ) );

}

{ //::gezi::write_libsvm

typedef void ( *write_libsvm_function_type )( ::gezi::Features const &,::std::string,::std::ostream & );

bp::def(
"write_libsvm"
, write_libsvm_function_type( &::gezi::write_libsvm )
, ( bp::arg("features"), bp::arg("label"), bp::arg("ofs") ) );

}

{ //::gezi::write_sparse

typedef void ( *write_sparse_function_type )( ::gezi::Features const &,::std::string,::std::ofstream &,::std::string );

bp::def(
"write_sparse"
, write_sparse_function_type( &::gezi::write_sparse )
, ( bp::arg("features"), bp::arg("label"), bp::arg("ofs"), bp::arg("name")="" ) );

}

{ //::gezi::write_table

typedef void ( *write_table_function_type )( ::gezi::Features const &,::std::string,::std::ofstream &,::std::string );

bp::def(
"write_table"
, write_table_function_type( &::gezi::write_table )
, ( bp::arg("features"), bp::arg("label"), bp::arg("ofs"), bp::arg("name")="" ) );

}

{ //::gezi::write_table_feature

typedef void ( *write_table_feature_function_type )( ::gezi::Features const &,::std::ofstream & );

bp::def(
"write_table_feature"
, write_table_feature_function_type( &::gezi::write_table_feature )
, ( bp::arg("features"), bp::arg("ofs") ) );

}

{ //::gezi::write_template

typedef void ( *write_template_function_type )( ::gezi::Features const &,::std::string );

bp::def(
"write_template"
, write_template_function_type( &::gezi::write_template )
, ( bp::arg("features"), bp::arg("outfile") ) );

}

bp::scope().attr("SEG_BASIC") = gezi::SEG_BASIC;

bp::scope().attr("SEG_HUMAN_NAME") = gezi::SEG_HUMAN_NAME;

bp::scope().attr("SEG_MERGE_NEWWORD") = gezi::SEG_MERGE_NEWWORD;

bp::scope().attr("SEG_NEWWORD") = gezi::SEG_NEWWORD;

bp::scope().attr("SEG_USE_ALL") = gezi::SEG_USE_ALL;

bp::scope().attr("SEG_USE_DEFAULT") = gezi::SEG_USE_DEFAULT;

bp::scope().attr("SEG_USE_POSTAG") = gezi::SEG_USE_POSTAG;

bp::scope().attr("SEG_USE_SPLIT") = gezi::SEG_USE_SPLIT;

bp::scope().attr("SEG_USE_TRIE") = gezi::SEG_USE_TRIE;

bp::scope().attr("SEG_WPCOMP") = gezi::SEG_WPCOMP;
}
