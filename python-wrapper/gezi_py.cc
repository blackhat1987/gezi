#define private public
#define protected public
#include "../include/python_util.h"
// This file has been generated by Py++.

#include "boost/python.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "../include/log_util.h"

#include "../include/Segmentor.h"
const int gezi::SegHandle::SEG_BUFF_SIZE;

#include "../include/ProgressBar.h"

#include "../include/tieba/util.h"

namespace bp = boost::python;

struct SegHandle_wrapper : gezi::SegHandle, bp::wrapper< gezi::SegHandle > {

SegHandle_wrapper(gezi::SegHandle const & arg )
: gezi::SegHandle( arg )
, bp::wrapper< gezi::SegHandle >(){
// copy constructor

}

SegHandle_wrapper( )
: gezi::SegHandle( )
, bp::wrapper< gezi::SegHandle >(){
// null constructor

}

SegHandle_wrapper(int bufsize )
: gezi::SegHandle( bufsize )
, bp::wrapper< gezi::SegHandle >(){
// constructor

}

static ::scw_out_t * get_pout(gezi::SegHandle const & inst ){
return inst.pout;
}

static void set_pout( gezi::SegHandle & inst, ::scw_out_t * new_value ){
inst.pout = new_value;
}

static ::token_t * get_tokens(gezi::SegHandle const & inst ){
return inst.tokens;
}

static void set_tokens( gezi::SegHandle & inst, ::token_t * new_value ){
inst.tokens = new_value;
}

};

BOOST_PYTHON_MODULE(libgezi){
UseStrVec;
UseIntVec;
UseFloatVec;
UseDoubleVec;
UseStrStrMap;
UseStrIntMap;
//UseStrIntHashMap;
UseStrFloatMap;
UseStrDoubleMap;

{ //::std::vector< token_t >
typedef bp::class_< std::vector< token_t > > vector_less__token_t__greater__exposer_t;
vector_less__token_t__greater__exposer_t vector_less__token_t__greater__exposer = vector_less__token_t__greater__exposer_t( "vector_less__token_t__greater_" );
bp::scope vector_less__token_t__greater__scope( vector_less__token_t__greater__exposer );
//WARNING: the next line of code will not compile, because "::token_t" does not have operator== !
//         vector_less__token_t__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< token_t > >() );
}

bp::class_< std::vector< std::string > >("vector_less__std_scope_string__greater_")
.def( bp::vector_indexing_suite< ::std::vector< std::string >, true >() );

{ //::gezi::LogHelper
typedef bp::class_< gezi::LogHelper > LogHelper_exposer_t;
LogHelper_exposer_t LogHelper_exposer = LogHelper_exposer_t( "LogHelper", bp::init< bp::optional< int > >(( bp::arg("log_level")=(int)(16) )) );
bp::scope LogHelper_scope( LogHelper_exposer );
bp::implicitly_convertible< int, gezi::LogHelper >();
LogHelper_exposer.def( bp::init< bool >(( bp::arg("with_conf") )) );
bp::implicitly_convertible< bool, gezi::LogHelper >();
LogHelper_exposer.def( bp::init< std::string const &, std::string const & >(( bp::arg("conf_path"), bp::arg("conf_file") )) );
{ //::gezi::LogHelper::set_level

typedef void ( *set_level_function_type )( int );

LogHelper_exposer.def(
"set_level"
, set_level_function_type( &::gezi::LogHelper::set_level )
, ( bp::arg("log_level") ) );

}
LogHelper_exposer.staticmethod( "set_level" );
}

bp::class_< gezi::NoProgressBar >( "NoProgressBar" )
.def(
"__call__"
, (void ( ::gezi::NoProgressBar::* )( ::size_t,::size_t ) const)( &::gezi::NoProgressBar::operator() )
, ( bp::arg("arg0"), bp::arg("arg1") ) );

{ //::gezi::ProgressBar
typedef bp::class_< gezi::ProgressBar > ProgressBar_exposer_t;
ProgressBar_exposer_t ProgressBar_exposer = ProgressBar_exposer_t( "ProgressBar", bp::init< >() );
bp::scope ProgressBar_scope( ProgressBar_exposer );
ProgressBar_exposer.def( bp::init< std::string const & >(( bp::arg("log_word") )) );
bp::implicitly_convertible< std::string const &, gezi::ProgressBar >();
ProgressBar_exposer.def( bp::init< size_t >(( bp::arg("total") )) );
bp::implicitly_convertible< size_t, gezi::ProgressBar >();
ProgressBar_exposer.def( bp::init< std::string const &, size_t >(( bp::arg("log_word"), bp::arg("total") )) );
{ //::gezi::ProgressBar::operator()

typedef void ( ::gezi::ProgressBar::*__call___function_type )( ::size_t ) ;

ProgressBar_exposer.def(
"__call__"
, __call___function_type( &::gezi::ProgressBar::operator() )
, ( bp::arg("current") ) );

}
{ //::gezi::ProgressBar::operator()

typedef void ( ::gezi::ProgressBar::*__call___function_type )( ::size_t,::size_t ) ;

ProgressBar_exposer.def(
"__call__"
, __call___function_type( &::gezi::ProgressBar::operator() )
, ( bp::arg("current"), bp::arg("total") ) );

}
ProgressBar_exposer.def( bp::self += bp::other< size_t >() );
{ //::gezi::ProgressBar::progress

typedef void ( ::gezi::ProgressBar::*progress_function_type )( ::size_t ) ;

ProgressBar_exposer.def(
"progress"
, progress_function_type( &::gezi::ProgressBar::progress )
, ( bp::arg("current") ) );

}
{ //::gezi::ProgressBar::progress

typedef void ( ::gezi::ProgressBar::*progress_function_type )( ::size_t,::size_t ) ;

ProgressBar_exposer.def(
"progress"
, progress_function_type( &::gezi::ProgressBar::progress )
, ( bp::arg("current"), bp::arg("total") ) );

}
}

{ //::gezi::SegHandle
typedef bp::class_< SegHandle_wrapper > SegHandle_exposer_t;
SegHandle_exposer_t SegHandle_exposer = SegHandle_exposer_t( "SegHandle", bp::init< >() );
bp::scope SegHandle_scope( SegHandle_exposer );
SegHandle_exposer.def( bp::init< int >(( bp::arg("bufsize") )) );
bp::implicitly_convertible< int, gezi::SegHandle >();
{ //::gezi::SegHandle::clear

typedef void ( ::gezi::SegHandle::*clear_function_type )(  ) ;

SegHandle_exposer.def(
"clear"
, clear_function_type( &::gezi::SegHandle::clear ) );

}
{ //::gezi::SegHandle::init

typedef void ( ::gezi::SegHandle::*init_function_type )( int ) ;

SegHandle_exposer.def(
"init"
, init_function_type( &::gezi::SegHandle::init )
, ( bp::arg("buf_size_")=(int)(gezi::SegHandle::SEG_BUFF_SIZE) ) );

}
SegHandle_exposer.def_readonly( "SEG_BUFF_SIZE", gezi::SegHandle::SEG_BUFF_SIZE );
SegHandle_exposer.def_readwrite( "buf_size", &gezi::SegHandle::buf_size );
SegHandle_exposer.def_readwrite( "nresult", &gezi::SegHandle::nresult );
SegHandle_exposer.add_property( "pout"
, bp::make_function( (::scw_out_t * (*)( ::gezi::SegHandle const & ))(&SegHandle_wrapper::get_pout), bp::return_internal_reference< >() )
, bp::make_function( (void (*)( ::gezi::SegHandle &,::scw_out_t * ))(&SegHandle_wrapper::set_pout), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
SegHandle_exposer.def_readwrite( "token_vec", &gezi::SegHandle::token_vec );
SegHandle_exposer.add_property( "tokens"
, bp::make_function( (::token_t * (*)( ::gezi::SegHandle const & ))(&SegHandle_wrapper::get_tokens), bp::return_internal_reference< >() )
, bp::make_function( (void (*)( ::gezi::SegHandle &,::token_t * ))(&SegHandle_wrapper::set_tokens), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
}

{ //::gezi::Segmentor
typedef bp::class_< gezi::Segmentor > Segmentor_exposer_t;
Segmentor_exposer_t Segmentor_exposer = Segmentor_exposer_t( "Segmentor", bp::init< bp::optional< int > >(( bp::arg("seg_buff_size")=(int)(gezi::SegHandle::SEG_BUFF_SIZE) )) );
bp::scope Segmentor_scope( Segmentor_exposer );
bp::implicitly_convertible< int, gezi::Segmentor >();
Segmentor_exposer.def( bp::init< std::string, bp::optional< int, int, std::string > >(( bp::arg("data_dir"), bp::arg("seg_buff_size")=(int)(gezi::SegHandle::SEG_BUFF_SIZE), bp::arg("strategy")=(int)(gezi::SEG_USE_DEFAULT), bp::arg("conf_path")="./conf/scw.conf" )) );
{ //::gezi::Segmentor::get_tokens

typedef int ( ::gezi::Segmentor::*get_tokens_function_type )( ::gezi::SegHandle &,int ) ;

Segmentor_exposer.def(
"get_tokens"
, get_tokens_function_type( &::gezi::Segmentor::get_tokens )
, ( bp::arg("handle"), bp::arg("type")=(int)(4) ) );

}
{ //::gezi::Segmentor::handle

typedef ::gezi::SegHandle & ( ::gezi::Segmentor::*handle_function_type )(  ) ;

Segmentor_exposer.def(
"handle"
, handle_function_type( &::gezi::Segmentor::handle )
, bp::return_internal_reference<>());

}
{ //::gezi::Segmentor::init

typedef bool ( ::gezi::Segmentor::*init_function_type )( ::std::string,int,::std::string ) ;

Segmentor_exposer.def(
"init"
, init_function_type( &::gezi::Segmentor::init )
, ( bp::arg("data_dir")="./data/wordseg", bp::arg("type")=(int)(gezi::SEG_USE_DEFAULT), bp::arg("conf_path")="./conf/scw.conf" ) );

}
{ //::gezi::Segmentor::seg_words

typedef bool ( ::gezi::Segmentor::*seg_words_function_type )( ::std::string,::gezi::SegHandle & ) ;

Segmentor_exposer.def(
"seg_words"
, seg_words_function_type( &::gezi::Segmentor::seg_words )
, ( bp::arg("input"), bp::arg("handle") ) );

}
{ //::gezi::Segmentor::segment

typedef bool ( ::gezi::Segmentor::*segment_function_type )( ::std::string,::gezi::SegHandle &,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("handle"), bp::arg("type")=(int)(4) ) );

}
{ //::gezi::Segmentor::segment

typedef bool ( ::gezi::Segmentor::*segment_function_type )( ::std::string,::gezi::SegHandle &,::std::vector< std::string > &,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("handle"), bp::arg("result"), bp::arg("type")=(int)(4) ) );

}
{ //::gezi::Segmentor::segment

typedef ::std::string ( ::gezi::Segmentor::*segment_function_type )( ::std::string,::gezi::SegHandle &,::std::string,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("handle"), bp::arg("sep"), bp::arg("type")=(int)(4) ) );

}
{ //::gezi::Segmentor::segment

typedef ::std::vector< std::string > ( ::gezi::Segmentor::*segment_function_type )( ::std::string,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("type")=(int)(4) ) );

}
{ //::gezi::Segmentor::segment

typedef ::std::string ( ::gezi::Segmentor::*segment_function_type )( ::std::string,::std::string,int ) ;

Segmentor_exposer.def(
"segment"
, segment_function_type( &::gezi::Segmentor::segment )
, ( bp::arg("input"), bp::arg("sep"), bp::arg("type")=(int)(4) ) );

}
{ //::gezi::Segmentor::set_buff_size

typedef ::gezi::Segmentor & ( ::gezi::Segmentor::*set_buff_size_function_type )( int ) ;

Segmentor_exposer.def(
"set_buff_size"
, set_buff_size_function_type( &::gezi::Segmentor::set_buff_size )
, ( bp::arg("buff_size") )
, bp::return_internal_reference<>());

}
{ //::gezi::Segmentor::set_flag

typedef ::gezi::Segmentor & ( ::gezi::Segmentor::*set_flag_function_type )( int ) ;

Segmentor_exposer.def(
"set_flag"
, set_flag_function_type( &::gezi::Segmentor::set_flag )
, ( bp::arg("flag") )
, bp::return_internal_reference<>());

}
}

bp::class_< gezi::SharedSegmentor >( "SharedSegmentor" )
.def(
"GetSegmentor"
, (::gezi::Segmentor & (*)(  ))( &::gezi::SharedSegmentor::GetSegmentor )
, bp::return_internal_reference<>())
.def(
"Instance"
, (::gezi::Segmentor * (*)(  ))( &::gezi::SharedSegmentor::Instance )
, bp::return_internal_reference<>())
.staticmethod( "GetSegmentor" )
.staticmethod( "Instance" );

bp::class_< gezi::ThreadLogHelper >( "ThreadLogHelper", bp::init< >() );

{ //::gezi::get_real_title

typedef ::std::string ( *get_real_title_function_type )( ::std::string );

bp::def(
"get_real_title"
, get_real_title_function_type( &::gezi::get_real_title )
, ( bp::arg("title") ) );

}

{ //::gezi::is_thread

typedef bool ( *is_thread_function_type )( ::std::string );

bp::def(
"is_thread"
, is_thread_function_type( &::gezi::is_thread )
, ( bp::arg("title") ) );

}

{ //::gezi::print_seg_result

typedef void ( *print_seg_result_function_type )( ::gezi::SegHandle const & );

bp::def(
"print_seg_result"
, print_seg_result_function_type( &::gezi::print_seg_result )
, ( bp::arg("handle") ) );

}

bp::scope().attr("SEG_BASIC") = gezi::SEG_BASIC;

bp::scope().attr("SEG_HUMAN_NAME") = gezi::SEG_HUMAN_NAME;

bp::scope().attr("SEG_MERGE_NEWWORD") = gezi::SEG_MERGE_NEWWORD;

bp::scope().attr("SEG_NEWWORD") = gezi::SEG_NEWWORD;

bp::scope().attr("SEG_USE_ALL") = gezi::SEG_USE_ALL;

bp::scope().attr("SEG_USE_DEFAULT") = gezi::SEG_USE_DEFAULT;

bp::scope().attr("SEG_USE_POSTAG") = gezi::SEG_USE_POSTAG;

bp::scope().attr("SEG_USE_SPLIT") = gezi::SEG_USE_SPLIT;

bp::scope().attr("SEG_USE_TRIE") = gezi::SEG_USE_TRIE;

bp::scope().attr("SEG_WPCOMP") = gezi::SEG_WPCOMP;
}
